# Onebite_React

## 섹션 1 - 들어가며
**React.js**는 Node.js 기반의 JavaScript 라이브러리
⇒ React는 JavaScript를 더 잘 쓰기 위한 일종의 도구일 뿐이다!

---
## 섹션 2 - JavaScript 기본
### 1.1) 안녕 자바스크립트

- JavaScript는 **오늘날 가장 많이 사용**되는 프로그래밍 언어
- JavaScript 역할: 웹 서버, 데스크탑 어플리케이션, 모바일 어플리케이션, 기타 등등
- JavaScript → HTML과 CSS와 함께, 웹페이지를 개발하기 위해 만들어진 언어
    - HTML의 역할: 요소들의 내용, 배치, 모양을 정하기 위해 사용하는 언어,, 색상이나 디자인 등의 수정은 불가
    - CSS의 역할: 요소들의 색상, 크기 등의 스타일을 설정할 수 있음
    - JavaScript의 역할: 웹 내부에서 발생하는 다양한 기능을 만들 수 있는 언어.  웹을 움직이게 하는 “웹의 근육”이라고 표현할 수 있음
- JavaScript는 어떻게 실행될까?
    - JavaScript는 “JavaScript 엔진”에 의해 실행된다.
    - 엔진은 게임 구동기, JavaScript는 게임이라고 이해하면 쉽다
    - JavaScript 엔진은 브라우저(크롬, 사파리..)에 기본 탑재되어 있다. 따라서 웹 브라우저를 이용하면 간단한 JavaScript 코드를 직접 실행해볼 수 있다.

    - console.log → 개발자 도구의 console 창에 출력

    - 실제 코드 구현은 개발자 도구X → Visual Studio Code
---
### 1.3) 자바스크립트 실습 환경 설정하기


- src → 경로, ‘.’ → 현재 경로


- 무조건! index.html 페이지에서 ctrl + shift + p → Live Server: Open with Live Server
    - 변경 사항을 저장할 때마다 웹페이지가 자동으로 새로고침 됨 → 우리가 설치한 플러그인인 Live Server가 코드에 변경사항이 발생하면 자동으로 페이지를 새로고침 시켜주기 때문에 index.html 페이지가 다시 렌더링되고 chapter03.js 파일도 다시 실행이 되기 때문에 그 결과 브라우저의 console tab에도 새로운 실행결과가 잘 나타나는 것을 볼 수 있음
- vs code 아래에 Port를 누르면 Live Server가 종료됨
---
### 1.4) 변수와 상수

- 변수, 상수는 값을 저장하는 박스


- 초기화가 이루어지지 않은 변수를 출력하면 undefined가 출력됨

1. **변수**
    - 중복된 이름으로 변수 선언 불가능
    - 변수라는 것은 프로그램이 실행되는 도중에 계속해서 값을 바꿔가면서 저장할 수 있는 저장소

2. **상수**
    - 상수도 변수와 마찬가지로 값을 저장하는 저장소
        - 차이점은 변수와 달리 한 번 저장된 값은 바꿀 수 없음
        - 상수는 값을 저장한다는 점은 변수와 동일하지만 초기화 이후에는 다시는 값을 바꿀 수 없다.
            
            
        - 상수는 변할 수 없거나 변하지 말아야 되는 값을 저장할 때 변수 대신에 자주 사용하게 됨
        - 상수는 값을 변화시키는 것 자체가 불가능하기 때문에 초기화가 반드시 필요함
        - 상수는 선언 이후에는 다시는 값을 넣어줄 수 없기 때문에 선언할 때 초기값을 할당하는 초기화를 무조건 해줘야 한다.

- 변수, 상수 모두 값을 저장한다는 점과 자신만의 이름을 갖는다는 점은 동일

3. **변수 명명규칙(네이밍 규칙)**
    
    3-1. $, _ 제외한 기호는 사용할 수 없다.
    
    3-2. 숫자로 시작할 수 없다.
    
    3-3. 예약어를 사용할 수 없다.
    

    - 예약어: let이나 const처럼 자바스크립트가 이미 특수한 의미로 사용하기로 약속한 단어들을 말한다.

1. **변수 명명 가이드**
    - 누가 봐도 바로 이해할 수 있는 변수명을 정성스럽게 지어주는 게 나중에 직접 수정하기에도 편하고 누군가와 협업을 할 때에도 서로 알아보기가 편하기 때문에 **친절하고 의미있는 변수명**으로 명명하는 게 좋다.
---
### 1.5) 자료형(타입)

- 자료형(Type) = **집합 -** 동일한 속성이나 특징을 가진 원소들을 묶은 것
    - ex) 고양이와 강아지는 “동물”이라는 집합으로 묶임
- 자료형(Type)은 “집합”이다.


- 원시 타입
    - 기본형 타입이라고도 불림
    - 프로그래밍에 있어 가장 기본적인 값들의 타입을 의미함
    1. **Number Type**
        - 자바스크립트의 넘버 타입은 존재할 수 있는 모든 숫자값들을 다 포함함
        - 기본적인 사칙연산들을 지원함, 나머지 구하는 연산도 가능(%) → 모듈러 연산이라고 함
        - NaN(Not a Number) - 우리가 수치연산에 실패했을 때, 결과값으로 보통 사용하게 됨

            
            - 자바스크립트에는 연산이 실패했을 경우에 반환하는 NaN과 같은 값이 있기 때문에 불가능한 수치 연산을 시키더라도 프로그램이 완전히 종료되어버리거나 하지 않음. 다른 언어에 비해 자바스크립트가 수학 연산에 안전하다.
    2. **String Type**
        - 문자열 값을 모두 포함하는 타입
        - 큰따옴표나 작은따옴표로 감싸줘야 한다. 그렇지 않으면 변수명으로 취급
            
            
        - 자바스크립트의 문자열은 독특하게 덧셈을 지원함

            
        - 백틱(`)으로도 만들 수 있음 - 기본적으로 쌍따옴표로 만든 문자열과 동일하지만, 백틱에서는 달러중괄호(${}), 문자열 안에 변수의 값을 동적으로 집어넣을 수 있음 → 템플릿 리터럴 문법
            
            
    3. **Boolean Type**
        - ture(참) or false(거짓)만 저장하는 타입
        - 타입의 값들은 어떠한 현재의 상태를 의미하는 데 주로 사용됨
    4. **Null Type (아무것도 없다)**
        - let empty = null → empty라는 변수에 어떠한 값도 들어있지 않다라는 것을 표현. null이라는 값은 어떠한 변수에 아무런 값도 담겨져 있지 않음을 표현하기 위해서 사용된다.
        - Null Type은 null을 포함하는 타입
    5. **Undefined Type**
        - Null Type처럼 undefined라는 단 하나의 값만 포함하는 특수한 타입
        - undefined라는 값은 우리가 변수를 선언하고 그 변수에 어떠한 값도 집어넣지 않았을 때 자동으로 할당이 되는 값
            
            
        - undefined는 진짜 변수를 선언하고 그 값에 어떠한 값도 할당하지 않았을 때 자동으로 들어가는 값
        - undefined라는 값은 변수를 미처 초기화하지 못했거나 존재하지 않는 값을 불러오려고 할 때 발생할 수 있는 값 ↔ null이라는 값은 우리가 직접 명시적으로 변수에 할당해줘야 하는 값, null은 프로그래머들이 직접 이 변수에 어떠한 값도 없다를 표현할 때 사용하는 값
---
### 1.6) 형 변환


**형 변환이란?**

형 변환 (Type Casting)

- 어떤 값의 타입을 다른 타입으로 변경하는 것을 말함


**형 변환 종류**

1. **묵시적 형 변환**
    1. 암묵적 형 변환
    2. 내가 굳이 얘기하지 않아도 자바스크립트 엔진이 눈치껏 타입을 변경하는 것
    3. 내가 생각지도 못하게 바뀔 수 있음
2. **명시적 형 변환**
    1. 묵시적 형 변환과 반대로, 명시적으로 내가 어떤 타입으로 이 값을 바꿔줘라는 명령을 통해서 값의 타입이 변경되는 것을 말함
    2. 내가 시켜야만 바뀜
        
    
        ⇒ 숫자 10과 문자열 20을 더하면 묵시적으로 숫자 10을 문자열 10으로 바꿔서 덧셈을 진행함
    
    - 모든 불가능한 연산에 이런 묵시적인 형 변환이 잘 일어나는 것은 아니고, 특정 하나의 변수의 값만 형 변환 했을 때 오류가 발생하지 않고 연산이 잘 종료될 수 있는 경우에만 이런 묵시적 형 변환이 일어나게 된다.
- 내장함수라는 것은 자바스크립트가 기본적으로 제공하는 함수들을 말함
- 문자열 안에 숫자 외 다른 문자열 값이 포함되어 있는 문자열 값을 형 변환할 때에는 Number 내장함수로 형 변환 불가능 → parseInt 내장함수 사용 → parseInt 내장함수를 쓸 때, 문자열이 앞에 나와있으면 형 변환이 잘 안 되는 경우가 있을 수 있기 때문에 숫자가 앞쪽으로 나와있어야 한다.
---
### 1.7) 연산자 1

**연산자(Operator)란?**

- 프로그래밍에서의 다양한 연산을 위한 **기호, 키워드**를 말함
    - 덧셈 연산자 +
    - 뺄셈 연산자 -
    - 곱셈 연산자 *
    - 나눗셈 연산자 /
    - 기타 등등…
- 산술 연산자 중 *, /, %가 +, -보다 우선순위가 높아서 먼저 계산됨
    - 우선순위가 낮은 연산부터 하고 싶으면 괄호로 묶어주면 됨
- 증감 연산자를 뒤에 적으면 그 다음줄이 되어서야 증감이 된다 → 증감이 바로 적용되게 하려면 복합 연산자를 사용하든지 증감 연산자를 앞에 적어
---
### 1.8) 연산자 2

1. **null 병합 연산자 (??)**

    - 존재하는 값을 추려내는 기능
    - null, undefined가 아닌 값을 찾아내는 연산자

2. **typeof 연산자**
    - 값의 타입을 문자열로 반환하는 기능을 하는 연산자
    - 현재 변수에 저장된 값의 타입이 궁금할 때, typeof 연산자 사용
    
    

- 자바스크립트의 거의 대다수의 연산자는 null 병합 연산자처럼 두 개의 항을 사용함

3. **삼항 연산자**
    - 항을 3개 사용하는 연산자
    - 조건식을 이용해서 참, 거짓일 때의 값을 다르게 반환
    
---
### 1.9) 조건문

**조건문(Conditional Statement) 이란?**

- 특정 조건을 만족했을 때에만 실행되는 코드를 작성하기 위한 문법
- 대표적으로 if, switch 조건문이 존재함


1. **if 조건문 (if문)**
    - 복잡한 여러 개의 조건을 이용하고 싶을 때, if문 이용
    - if 문은 꼭 if로 시작
    - else if 앞에 else 사용 불가
    - else로 끝나는 게 보통이지만 꼭 else 안 적어도 됨 → if나 else if로 끝나는 것 가능
    
    
2. **Switch 문**
    - 어떠한 변수의 값을 기준으로 각각 다른 코드를 실행시키고 싶을 때, switch 문 이용
    - if문과 기능 자체는 동일
    - 다수의 조건을 처리할 때 if보다 더 직관적이다.
    - switch 문 소괄호 안에는 비교할 **변수**가 들어감
    - break 없을 시, 일치하는 case의 아래 코드까지 전부 출력
    - switch 문은 기본적으로 거의 모든 case에 break를 필수적으로 달아주어야 한다.
    - default - 어떠한 경우에도 일치하지 않는 경우를 대비해 사용
    
---
### 1.10) 반복문

반복문 (Loop, Iteration)

- 어떠한 동작을 반복해서 수행할 수 있도록 만들어 주는 문법


- 반복문을 사용 → 동일한 기능을 쉽게 만들어낼 수 있음


- **초기식**: 반복문 내부에서만 이용할 수 있는 특별한 **변수를 초기화**하기 위해서 사용하는 식
    - 이 반복문 내부에서만 이용할 수 있는 변수 = 이 반복이 지금 현재 총 몇 번 진행되었는지 count하는 값을 저장하는 변수, 카운터 변수라고 부르기도 함
- **조건식**: 이 반복문이 **언제까지 반복할 건지** 설정하는 식
    - 조건식이 참일 때만 반복
    - 거짓이 되면 종료
- **증감식**: 한 번의 반복이 종료될 때마다, 즉 매 반복마다 **카운터 변수인 idx를 증가**시키는 용도로 사용됨
    - 증가를 시켜줘야 몇 번 반복했는지 셀 수 있음
    - 증가시키는 용도로 활용한다.

**[반복문을 중간에 조건식이 거짓이 되지 않았을 때에도 강제로 종료하는 법]**

- 반복문 block 내에서 if 조건문 사용


**[반복의 특정 회차 건너뛰는 방법]**

- if ~ continue
    - continue문을 만나게 되면 이 반복문 내의 다른 코드들은 실행하지 않고 바로 다음 반복 회차로 넘어가게 된다.

---
### 1.11) 함수

중복으로 작성된 코드들

- 생산성 떨어짐
- 향후 코드를 수정하거나 유지보수할 때 큰 문제가 될 수 있음

⇒ **함수로 해결 가능**


- 함수 선언: 함수를 새롭게 만드는 행위
    
    - 함수는 선언했다고 바로 실행되는 것이 아니고, 함수를 호출했을 때만 실행이 된다.
    - 함수 선언이라는 건 함수가 호출되었을 때 어떤 코드를 실행할 것인지 미리 준비해두는 작업
    - 함수를 호출할 때는 반드시 소괄호와 함께 호출해야 한다!
    - 함수가 호출되면 프로그램의 실행 순서가 함수 내부로 넘어간다.
        
        

**함수**


- 함수의 소괄호 안엔 변수 이름만 써줘도 됨
- 함수를 호출하면서 함수에게 전달한 값들을 각각 “인수”라고 부름
- 전달된 인수들을 순서대로 저장하는 특수한 함수의 변수들을 “매개변수”라고 부름, 매개채 역할을 하는 변수
- 함수를 호출하면서 10과 20이라는 인수를 전달해주면 전달된 인수는 함수의 매개변수의 순서대로 각각 10과 20이 저장이 된다.

- console.log 대신 return 사용 → 반환값(=함수 호출의 결과값) 존재 → 변수에 담아서 활용할 수 있음
    
    
    - return 문을 활용하면 함수가 어떠한 결과값을 반환하도록 만들어줄 수 있다.
    - 함수가 return 문을 만나게 되면 값을 반환하고 바로 종료가 된다 → return 문 밑에 코드를 추가적으로 작성하여도 그 코드는 실질적으로 실행이 되지 않는다.
- 자바스크립트는 함수 안에 또 다른 함수를 선언하는 것도 가능
    - 함수 안에 또 다른 함수를 중첩 함수라고 부름
    
    
- 자바스크립트에서는 함수 선언을 함수 호출보다 아래에 두어도 아무런 문제없이 잘 수행된다.
    - C나 Java처럼 선언이 되지 않은 함수를 미리 호출하려고 하면 오류를 발생시키는 게 일반적이지만 자바스크립트는 그렇지 않다. 정상적으로 실행이 된다.
    - 자바스크립트의 호이스팅이라는 기능 때문
        - 호이스팅 → 끌어올리다 라는 뜻
        - 자바스크립트에서의 호이스팅이란, 코드의 밑바닥에 작성된 선언문들을 코드를 실행하기 전에 코드의 최상단으로 끌어올려서 실행시켜주는 기능을 말한다. 그렇기 때문에 함수 선언문을 호출문보다 아래에 두어도 내부적으로 알아서 호이스팅되어서(끌어올려져서) 실행이 되기 때문에 아무런 문제가 발생하지 않는다.
        - 호이스팅 덕분에 함수 선언이 무조건 위에 있지 않아도 되기 때문에 좀 더 유연하게 프로그래밍을 진행할 수 있다.
---
### 1.12) 함수 표현식과 화살표 함수

1. **함수 표현식**


    - 함수도 숫자나 문자열과 같은 하나의 값으로써 취급하기 때문에 함수 자체를 변수에 담아놓을 수 있음
    - 어떤 함수를 변수에 담게 되면 함수를 변수의 이름으로 호출해줄 수 있음
    - 함수를 만들자마자 바로 변수에 담아버리는 것도 가능
    - 선언식이라는 것은 어떤 변수로써 담기지 않은 상태로 유지가 되어야 함
    - 값으로써 함수가 생성된 것임 → 함수의 이름으로 호출 불가 → 함수의 이름으로 못 부름 → 함수 이름 생략 → 이름이 없는 함수: 익명 함수
    - 함수 선언문을 이용해서 함수를 만들지 않고 대신 값으로써 함수를 생성하는 방식을 자바스크립트에서 함수 표현식이라고 부름
    - 함수 표현식으로 만든 함수들은 값으로써 취급이 되기 때문에 호이스팅이 되는 함수 선언문으로 만든 함수와 달리 함수 표현식으로 만든 함수들은 호이스팅의 대상이 되지 않는다.

2. **화살표 함수**

    - 함수를 이전보다 더 빠르고 간결하게 생성할 수 있도록 도와주는 자바스크립트 문법
    - function 지우고 소괄호와 대괄호 사이에 화살표 삽입
    - 값을 반환하기만 하는 함수일 때, 중괄호와 return 문을 지워도 됨
    - 매개변수가 필요하면 소괄호 안에 매개변수를 선언해주면 됨

---
### 1.13) 콜백함수

1. **콜백함수**

    콜백 함수(Callback Function)란?

    - 자신이 아닌 다른 함수에, 인수로써 전달된 함수를 의미함
    ```jsx
    // 1. 콜백함수
    function main(value) {
        console.log(1)
        console.log(2)
        value()
        console.log("end")
    }

    function sub() {
        console.log("i am sub")
    }

    main(sub)

    /*
    1
    2
    i am sub
    end
    */
    ```
    - sub 함수 → Callback 함수
    - 어떠한 함수를 다른 함수의 인수로 전달해서 나중에 호출시키도록, 해당 함수에서 알아서 호출하도록 설정한 sub와 같은 함수를 콜백함수라고 부름
    - 콜백 → 프로그래밍에서는 “뒷전에 실행되는” 또는 “나중에 실행되는”이라는 뜻으로 쓰임
    - 콜백함수는 메인함수가 언제든지 원하는 타이밍에 실행시킬 수 있다.

2. **콜백함수의 활용**
    -  콜백함수를 활용하면 중복코드를 발생시키지 않으면서 코드를 크게 개선할 수 있음

---
### 1.14) 스코프

**스코프(Scope)란?**

- 우리말로 “범위”를 뜻함
- 변수나 함수에 접근하거나 호출할 수 있는 범위를 말함


- 변수가 선언된 함수나 조건문이나 반복문 같은 중괄호를 이용해서 만들어진 블록 내부에서는 변수에 접근할 수 있지만, 그렇지 않은 영역에서는 접근할 수가 없다.
- 변수에 접근할 수 있는 영역을 스코프라고 부르고, 변수 a는 funcA라는 지역적인 스코프를 갖는다고 표현할 수 있다.
- 어떠한 함수나 반복문이나 조건문에 갇히지 않은 상태로, 완전히 바깥 위치에 변수를 선언하면 이 변수는 어디에서나 접근 가능해짐 → 전역 스코프를 갖는 변수가 됨
- 중괄호 안쪽을 블록이라고 부름
- 블록 내에 선언된 모든 변수들은 다 지역 스코프를 갖는다.
- 지역 스코프 → 외부(중괄호 바깥)에서 접근하려고 하면 오류 발생
- 반복문의 초기식에 선언된 변수도 지역 스코프를 갖기 때문에 반복문 외부에서는 접근할 수 없다.
- 함수도 변수처럼 지역 스코프를 가질 수 있다.
    - 예외적으로, **함수 선언식은 반복문이나 조건문 안에서는 지역 스코프를 갖지 않는다.**
    - 함수 선언식은 특별하게 함수 블록 안에서만 지역 스코프를 갖고, 나머지 for문이나 if문 안에서는 지역 스코프를 갖지 않는다.

---
### 1.15) 객체 1

**객체(Object)란?**

- 원시 타입이 아닌 객체 타입의 자료형
- 여러 가지 값을 동시에 저장할 수 있는 자료형을 의미


- 객체를 이용하면 현실세계에 존재하는 어떤 사물이나 개념을 표현하기 용이함


1. **객체 생성**

    1.1 객체 생성자라고 불리는 내장함수 사용 - new Object()

    1.2 빈 중괄호 → 객체 리터럴 (대부분 사용 - 간결하기 때문) - {}
    
    
2. **객체 프로퍼티 (객체 속성)**
    - key: value → key의 이름을 가지고 불리게 됨
    - 객체 안에 저장되어 있는 객체의 정보값들 → 객체 속성
    - 객체의 실질적인 정보를 담고 있는 역할
    - 프로퍼티의 개수에는 제한이 없음
    - value에 들어올 수 있는 자료형의 타입에도 제한이 없음
        - boolean, 함수, 객체 등등
    - key 값으로는 문자열이나 숫자만 이용 가능
    - 프로퍼티의 key로 사용되는 문자열에는 따옴표를 붙이지 않아도 되는데, 예외적으로 띄어쓰기가 포함된 문자열을 key로 사용하고자 한다면 이때에는 예외적으로 따옴표를 사용해야 한다.
    
    
3. **객체 프로퍼티를 다루는 방법**
    
    3.1. 특정 프로퍼티에 접근 (점 표기법, 괄호 표기법)
    
    - 점 표기법
        - key로 접근
        - value를 출력
        - 존재하지 않는 프로퍼티의 값을 꺼내오려고 하면 오류가 발생하지는 않고, undefined가 반환됨
    - 괄호 표기법
        - 대괄호 안에 접근하고자 하는 프로퍼티의 키를 명시
            - 쌍따옴표와 함께 문자열로 작성해야 함
            - 쌍따옴표 없이 작성 → 변수로 취급
        - 존재하지 않는 프로퍼티의 값을 꺼내오려고 하면 오류가 발생하지는 않고, undefined가 반환됨
        - 변수에 접근하고자 하는 key 값을 담아서 프로퍼티를 꺼내오도록 설정할 수 있기 때문에 동적으로 프로퍼티를 변화시키면서 꺼내와야 할 때, 괄호 표기법 이용, 그게 아니라면 문법이 훨씬 간결한 점 표기법을 이용하는 게 좋다.
    
    3.2 새로운 프로퍼티를 추가하는 방법
    
    ```jsx
    // 3.2 새로운 프로퍼티를 추가하는 방법
    person.job = "fe developer" 
    person["favoriteFood"] = "떡볶이"
    ```
    
    3.3 프로퍼티를 수정하는 방법
    
    ```jsx
    // 3.3 프로퍼티를 수정하는 방법
    person.job = "educator" 
    person["favoriteFood"] = "초콜릿"
    ```
    
    3.4 프로퍼티를 삭제하는 방법
    
    - delete라는 특별한 연산자를 이용
    - delete 연산자 뒤에 삭제하고자 하는 프로퍼티를 작성
    
    
    3.5 프로퍼티의 존재 유무를 확인하는 방법
    
    - in 연산자 이용
    - 특정 개체에 특정 프로퍼티가 존재하는지 유무를 알 수 있다.
    
---
### 1.16) 객체 2

1. **상수 객체**
    - 상수에 저장한 객체
    - 저장된 값을 바꿀 수 없음
    - 상수 객체에 다른 객체를 생성해서 할당하는 건 당연히 오류가 발생
    - 객체에 새로운 프로퍼티를 추가하거나 기존 객체에 들어있던 프로퍼티의 값을 수정하거나 객체 프로퍼티를 삭제하는 행위는 가능함
    - 상수에 저장된 객체도 프로퍼티를 추가하거나 수정하거나 삭제하는 게 가능 → 가능한 이유: 상수라는 건 엄밀히 말하자면 새로운 값을 할당하지 못하는 변수를 말함 → 아예 새로운 값을 할당하는 것은 문제가 되지만, 저장되어 있는 객체 값의 프로퍼티를 수정하는 건 아무런 문제가 되지 않는다. 그렇기 때문에 상수에 객체를 보관한다 하더라도 프로퍼티를 추가하거나 수정하거나 삭제하는 조작은 얼마든지 가능하다.
    

2. **메서드**
    - 객체 프로퍼티들 중에서 값이 함수인 프로퍼티를 말함
    - 메서드는 함수이기 때문에 당연히 호출하는 것 또한 가능
    - 메서드는 익명 함수로 만들 수도 있지만 화살표 함수로도 만들 수 있고 화살표 함수보다 더 단축된 형태로도 만들 수 있음
    - 메서드들은 어떻게 선언이 되든 점 표기법이나 괄호 표기법을 이용해서 호출을 할 수 있다.
    - 메서드는 보통, 객체의 동작을 정의하는 데 사용이 된다. → 함수가 아닌 프로퍼티들이 객체의 정보를 갖고 있다면, 함수 프로퍼티들은 메서드로써 객체의 동작을 정의한다.
    
---
### 1.17) 배열

**배열(Array)이란?**

- 여러 개의 값을 **순차적**으로 담을 수 있는 자료형
- 객체와 동일하게 여러 개의 값을 담을 수 있는 자료형
- 객체와의 차이점은 배열은 이 값들을 순차적으로 담는다.


1. **배열 생성**

    1.1 배열 생성자 - new Array()

    1.2 배열 리터럴 - []
    
    
    - 배열 안에는 어떤 타입의 값이든 자유롭게 다 넣을 수 있음
        - boolean, 문자열, null, undefined, 화살표 함수, 객체, 새로운 배열 등등
    - 길이의 한계도 없다.
    - 저장하고 싶은 데이터를 쉽게 순차적으로 보관할 수 있음
2. **배열 요소 접근**
    - 배열이라는 자료형은 순서대로 값을 저장하기 때문에 각각의 원소에 번호로 접근할 수 있다.
    - 인덱스: 배열의 원소 중에 몇 번째 원소를 가져오고 싶은지 의미하는 숫자
    - 배열의 인덱스, 즉 순서는 0부터 시작
    - 특정 원소의 값을 수정하는 것도 가능


---
## 섹션 3 - JavaScript 심화
### **2.1) Truthy와 Falsy**

- JavaScript는 어떠한 값이 boolean 타입에 해당하는 참이거나 거짓이지 않아도 상황에 따라서 참으로 판단하거나 거짓으로 판단하는 경우가 있다.


**Truthy & Falsy란?**

- 참이나 거짓을 의미하지 않는 값도, 조건문 내에서 참이나 거짓으로 평가하는 특징


**JavaScript의 모든 값은 Truthy 하거나 Falsy 하다**

- 이를 이용하면 조건문을 간결하게 만들 수 있음

1. **Falsy 한 값**
    - JavaScript에는 총 7가지의 Falsy 한 값 존재
    ```jsx
    // 1. Falsy 한 값
    let f1 = undefined
    let f2 = null
    let f3 = 0
    let f4 = -0
    let f5 = NaN
    let f6 = ""
    let f7 = 0n

    if (!f1) {
        console.log("falsy")    // falsy
    }
    ```
    - 조건문에서 거짓으로 평가됨
    - 0n → big integer라는 특수한 자료형에 해당하는 값
        - 아주 아주 큰 숫자를 저장하는데 사용되는 값
        - 보통 웹 개발 중에는 잘 이용하지 않음
    
    
2. **Truthy 한 값**
    - 7가지 Falsy 한 값들 제외한 나머지 모든 값
    
    

1. **활용 사례**
    - 변수가 undefined → undefined의 프로퍼티는 읽을 수 없음 → 오류 발생
    - 매개변수로 객체를 받을 것이라고 생각했는데 실제로는 undefined의 값이 들어오는 상황은 실제 서비스를 개발하다 보면 정말 자주 발생하는 상황 → 객체의 특정 프로퍼티에 접근하는 기능을 담고 있는 함수에서는 보통 조건문으로 매개변수의 값이 null이나 undefined이 아님을 먼저 확인해줘야 함
    - 복잡한 조건문 → 비효율적 ⇒ falsy를 이용해 조건문 개선


### **2.2) 단락 평가**

**단락 평가(Short-circuit Evaluation)란?**

- and나 or 같은 논리 연산식에서 첫 번째 피연산자 값만으로도 해당 연산의 결과를 확정할 수 있다면 두 번째 피연산자에는 접근조차 하지 않는 실행 방식


1. **AND 연산자**
    - 첫 번째 피연산자 값이 false라면 두 번째 피연산자 값이 무엇이든 항상 false
    - 첫 번째 값이 true라면 두 번째 값이 true인지 false인지에 따라 연산 결과가 달라지기 때문에 두 번째 값도 확인해야 함
2. **OR 연산자**
    - 첫 번째 피연산자 값이 true라면 두 번째 피연산자 값이 무엇이든 항상 ture
- 단락 평가를 이용하면 앞으로 조건문을 이용하지 않고도 특정 상황에서 어떠한 함수를 호출하지 않도록 방지하거나 어떠한 값들을 굳이 계산하지 않도록 제한하는 등의 아주 다양한 기능들을 개발할 수 있음
- 특정 조건에 맞춰서 함수를 아예 호출하지 않도록 방지할 수 있는 기능을 가지고 있다.
- 단락 평가는 true나 false와 같은 boolean 값 뿐만 아니라 Truthy한 값이나 Falsy한 값에도 당연히 적용이 된다.
    - 이때, 출력(연산의 결과값)되는 것은 true나 false가 아니라 Truthy한 값 or Falsy한 값 자체


- 단락 평가 활용 사례
    ```jsx
    // 단락 평가 활용 사례
    function printName(person) {
        const name = person && person.name
        console.log(name || "person의 값이 없음")
    }

    printName()     // person의 값이 없음
    printName({ name: "이정환" })    // 이정환
    ```
    - person 값이 있을 때
        - person이 true이기 때문에 person.name 확인 → truthy && truthy일 경우, 두 번째 truthy한 값 저장
        - name || “person의 값이 없음” → truthy || truthy일 경우, 첫 번째 truthy한 값 반환