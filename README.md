# Onebite_React

## 섹션 1 - 들어가며
**React.js**는 Node.js 기반의 JavaScript 라이브러리
⇒ React는 JavaScript를 더 잘 쓰기 위한 일종의 도구일 뿐이다!

---
## 섹션 2 - JavaScript 기본
### 1.1) 안녕 자바스크립트

- JavaScript는 **오늘날 가장 많이 사용**되는 프로그래밍 언어
- JavaScript 역할: 웹 서버, 데스크탑 어플리케이션, 모바일 어플리케이션, 기타 등등
- JavaScript → HTML과 CSS와 함께, 웹페이지를 개발하기 위해 만들어진 언어
    - HTML의 역할: 요소들의 내용, 배치, 모양을 정하기 위해 사용하는 언어,, 색상이나 디자인 등의 수정은 불가
    - CSS의 역할: 요소들의 색상, 크기 등의 스타일을 설정할 수 있음
    - JavaScript의 역할: 웹 내부에서 발생하는 다양한 기능을 만들 수 있는 언어.  웹을 움직이게 하는 “웹의 근육”이라고 표현할 수 있음
- JavaScript는 어떻게 실행될까?
    - JavaScript는 “JavaScript 엔진”에 의해 실행된다.
    - 엔진은 게임 구동기, JavaScript는 게임이라고 이해하면 쉽다
    - JavaScript 엔진은 브라우저(크롬, 사파리..)에 기본 탑재되어 있다. 따라서 웹 브라우저를 이용하면 간단한 JavaScript 코드를 직접 실행해볼 수 있다.

    - console.log → 개발자 도구의 console 창에 출력

    - 실제 코드 구현은 개발자 도구X → Visual Studio Code
---
### 1.3) 자바스크립트 실습 환경 설정하기


- src → 경로, ‘.’ → 현재 경로


- 무조건! index.html 페이지에서 ctrl + shift + p → Live Server: Open with Live Server
    - 변경 사항을 저장할 때마다 웹페이지가 자동으로 새로고침 됨 → 우리가 설치한 플러그인인 Live Server가 코드에 변경사항이 발생하면 자동으로 페이지를 새로고침 시켜주기 때문에 index.html 페이지가 다시 렌더링되고 chapter03.js 파일도 다시 실행이 되기 때문에 그 결과 브라우저의 console tab에도 새로운 실행결과가 잘 나타나는 것을 볼 수 있음
- vs code 아래에 Port를 누르면 Live Server가 종료됨
---
### 1.4) 변수와 상수

- 변수, 상수는 값을 저장하는 박스


- 초기화가 이루어지지 않은 변수를 출력하면 undefined가 출력됨

1. **변수**
    - 중복된 이름으로 변수 선언 불가능
    - 변수라는 것은 프로그램이 실행되는 도중에 계속해서 값을 바꿔가면서 저장할 수 있는 저장소

2. **상수**
    - 상수도 변수와 마찬가지로 값을 저장하는 저장소
        - 차이점은 변수와 달리 한 번 저장된 값은 바꿀 수 없음
        - 상수는 값을 저장한다는 점은 변수와 동일하지만 초기화 이후에는 다시는 값을 바꿀 수 없다.
            
            
        - 상수는 변할 수 없거나 변하지 말아야 되는 값을 저장할 때 변수 대신에 자주 사용하게 됨
        - 상수는 값을 변화시키는 것 자체가 불가능하기 때문에 초기화가 반드시 필요함
        - 상수는 선언 이후에는 다시는 값을 넣어줄 수 없기 때문에 선언할 때 초기값을 할당하는 초기화를 무조건 해줘야 한다.

- 변수, 상수 모두 값을 저장한다는 점과 자신만의 이름을 갖는다는 점은 동일

3. **변수 명명규칙(네이밍 규칙)**
    
    3-1. $, _ 제외한 기호는 사용할 수 없다.
    
    3-2. 숫자로 시작할 수 없다.
    
    3-3. 예약어를 사용할 수 없다.
    

    - 예약어: let이나 const처럼 자바스크립트가 이미 특수한 의미로 사용하기로 약속한 단어들을 말한다.

1. **변수 명명 가이드**
    - 누가 봐도 바로 이해할 수 있는 변수명을 정성스럽게 지어주는 게 나중에 직접 수정하기에도 편하고 누군가와 협업을 할 때에도 서로 알아보기가 편하기 때문에 **친절하고 의미있는 변수명**으로 명명하는 게 좋다.
---
### 1.5) 자료형(타입)

- 자료형(Type) = **집합 -** 동일한 속성이나 특징을 가진 원소들을 묶은 것
    - ex) 고양이와 강아지는 “동물”이라는 집합으로 묶임
- 자료형(Type)은 “집합”이다.


- 원시 타입
    - 기본형 타입이라고도 불림
    - 프로그래밍에 있어 가장 기본적인 값들의 타입을 의미함
    1. **Number Type**
        - 자바스크립트의 넘버 타입은 존재할 수 있는 모든 숫자값들을 다 포함함
        - 기본적인 사칙연산들을 지원함, 나머지 구하는 연산도 가능(%) → 모듈러 연산이라고 함
        - NaN(Not a Number) - 우리가 수치연산에 실패했을 때, 결과값으로 보통 사용하게 됨

            
            - 자바스크립트에는 연산이 실패했을 경우에 반환하는 NaN과 같은 값이 있기 때문에 불가능한 수치 연산을 시키더라도 프로그램이 완전히 종료되어버리거나 하지 않음. 다른 언어에 비해 자바스크립트가 수학 연산에 안전하다.
    2. **String Type**
        - 문자열 값을 모두 포함하는 타입
        - 큰따옴표나 작은따옴표로 감싸줘야 한다. 그렇지 않으면 변수명으로 취급
            
            
        - 자바스크립트의 문자열은 독특하게 덧셈을 지원함

            
        - 백틱(`)으로도 만들 수 있음 - 기본적으로 쌍따옴표로 만든 문자열과 동일하지만, 백틱에서는 달러중괄호(${}), 문자열 안에 변수의 값을 동적으로 집어넣을 수 있음 → 템플릿 리터럴 문법
            
            
    3. **Boolean Type**
        - ture(참) or false(거짓)만 저장하는 타입
        - 타입의 값들은 어떠한 현재의 상태를 의미하는 데 주로 사용됨
    4. **Null Type (아무것도 없다)**
        - let empty = null → empty라는 변수에 어떠한 값도 들어있지 않다라는 것을 표현. null이라는 값은 어떠한 변수에 아무런 값도 담겨져 있지 않음을 표현하기 위해서 사용된다.
        - Null Type은 null을 포함하는 타입
    5. **Undefined Type**
        - Null Type처럼 undefined라는 단 하나의 값만 포함하는 특수한 타입
        - undefined라는 값은 우리가 변수를 선언하고 그 변수에 어떠한 값도 집어넣지 않았을 때 자동으로 할당이 되는 값
            
            
        - undefined는 진짜 변수를 선언하고 그 값에 어떠한 값도 할당하지 않았을 때 자동으로 들어가는 값
        - undefined라는 값은 변수를 미처 초기화하지 못했거나 존재하지 않는 값을 불러오려고 할 때 발생할 수 있는 값 ↔ null이라는 값은 우리가 직접 명시적으로 변수에 할당해줘야 하는 값, null은 프로그래머들이 직접 이 변수에 어떠한 값도 없다를 표현할 때 사용하는 값
---
### 1.6) 형 변환


**형 변환이란?**

형 변환 (Type Casting)

- 어떤 값의 타입을 다른 타입으로 변경하는 것을 말함


**형 변환 종류**

1. **묵시적 형 변환**
    1. 암묵적 형 변환
    2. 내가 굳이 얘기하지 않아도 자바스크립트 엔진이 눈치껏 타입을 변경하는 것
    3. 내가 생각지도 못하게 바뀔 수 있음
2. **명시적 형 변환**
    1. 묵시적 형 변환과 반대로, 명시적으로 내가 어떤 타입으로 이 값을 바꿔줘라는 명령을 통해서 값의 타입이 변경되는 것을 말함
    2. 내가 시켜야만 바뀜
        
    
        ⇒ 숫자 10과 문자열 20을 더하면 묵시적으로 숫자 10을 문자열 10으로 바꿔서 덧셈을 진행함
    
    - 모든 불가능한 연산에 이런 묵시적인 형 변환이 잘 일어나는 것은 아니고, 특정 하나의 변수의 값만 형 변환 했을 때 오류가 발생하지 않고 연산이 잘 종료될 수 있는 경우에만 이런 묵시적 형 변환이 일어나게 된다.
- 내장함수라는 것은 자바스크립트가 기본적으로 제공하는 함수들을 말함
- 문자열 안에 숫자 외 다른 문자열 값이 포함되어 있는 문자열 값을 형 변환할 때에는 Number 내장함수로 형 변환 불가능 → parseInt 내장함수 사용 → parseInt 내장함수를 쓸 때, 문자열이 앞에 나와있으면 형 변환이 잘 안 되는 경우가 있을 수 있기 때문에 숫자가 앞쪽으로 나와있어야 한다.
---
### 1.7) 연산자 1

**연산자(Operator)란?**

- 프로그래밍에서의 다양한 연산을 위한 **기호, 키워드**를 말함
    - 덧셈 연산자 +
    - 뺄셈 연산자 -
    - 곱셈 연산자 *
    - 나눗셈 연산자 /
    - 기타 등등…
- 산술 연산자 중 *, /, %가 +, -보다 우선순위가 높아서 먼저 계산됨
    - 우선순위가 낮은 연산부터 하고 싶으면 괄호로 묶어주면 됨
- 증감 연산자를 뒤에 적으면 그 다음줄이 되어서야 증감이 된다 → 증감이 바로 적용되게 하려면 복합 연산자를 사용하든지 증감 연산자를 앞에 적어
---
### 1.8) 연산자 2

1. **null 병합 연산자 (??)**

    - 존재하는 값을 추려내는 기능
    - null, undefined가 아닌 값을 찾아내는 연산자
    ```jsx
    // 1. null 병합 연산자

    let var1    // undefined
    let var2 = 10
    let var3 = 20

    let var4 = var1 ?? var2 // var4 = 10
    let var5 = var1 ?? var3 // var5 = 20
    let var6 = var2 ?? var3 // 둘 다 null이나 undefined가 아닐 경우, 첫 번째 값이 반환이 됨
    console.log(var6)    // var6 = 10

    // userName이 있으면 userName을 보여주고, 아니면 userNickName 보여주기
    let userName = "이정환"
    let userNickName = "Winterlood"

    let displayName = userName ?? userNickName
    ```

2. **typeof 연산자**
    - 값의 타입을 문자열로 반환하는 기능을 하는 연산자
    - 현재 변수에 저장된 값의 타입이 궁금할 때, typeof 연산자 사용
    
    ```jsx
    // 2. typeof 연산자

    let var7 = 1
    var7 = "hello"  // 변수의 타입이 고정되어 있지 않음
    var7 = true

    let t1 = typeof var7
    console.log(t1) // -> boolean
    ```
    

- 자바스크립트의 거의 대다수의 연산자는 null 병합 연산자처럼 두 개의 항을 사용함

3. **삼항 연산자**
    - 항을 3개 사용하는 연산자
    - 조건식을 이용해서 참, 거짓일 때의 값을 다르게 반환
    ```jsx
    // 3. 삼항 연산자
    let var8 = 10

    // 요구사항 : 변수 res에 var8의 값이 짝수 -> "짝수", 홀수 -> "홀수"
    let res = var8 % 2 === 0 ? "짝수" : "홀수"
    console.log(res)    // 짝수
    ```
    
---
### 1.9) 조건문

**조건문(Conditional Statement) 이란?**

- 특정 조건을 만족했을 때에만 실행되는 코드를 작성하기 위한 문법
- 대표적으로 if, switch 조건문이 존재함


1. **if 조건문 (if문)**
    - 복잡한 여러 개의 조건을 이용하고 싶을 때, if문 이용
    - if 문은 꼭 if로 시작
    - else if 앞에 else 사용 불가
    - else로 끝나는 게 보통이지만 꼭 else 안 적어도 됨 → if나 else if로 끝나는 것 가능
    
    
2. **Switch 문**
    - 어떠한 변수의 값을 기준으로 각각 다른 코드를 실행시키고 싶을 때, switch 문 이용
    - if문과 기능 자체는 동일
    - 다수의 조건을 처리할 때 if보다 더 직관적이다.
    - switch 문 소괄호 안에는 비교할 **변수**가 들어감
    - break 없을 시, 일치하는 case의 아래 코드까지 전부 출력
    - switch 문은 기본적으로 거의 모든 case에 break를 필수적으로 달아주어야 한다.
    - default - 어떠한 경우에도 일치하지 않는 경우를 대비해 사용
    
---
### 1.10) 반복문

반복문 (Loop, Iteration)

- 어떠한 동작을 반복해서 수행할 수 있도록 만들어 주는 문법


- 반복문을 사용 → 동일한 기능을 쉽게 만들어낼 수 있음


- **초기식**: 반복문 내부에서만 이용할 수 있는 특별한 **변수를 초기화**하기 위해서 사용하는 식
    - 이 반복문 내부에서만 이용할 수 있는 변수 = 이 반복이 지금 현재 총 몇 번 진행되었는지 count하는 값을 저장하는 변수, 카운터 변수라고 부르기도 함
- **조건식**: 이 반복문이 **언제까지 반복할 건지** 설정하는 식
    - 조건식이 참일 때만 반복
    - 거짓이 되면 종료
- **증감식**: 한 번의 반복이 종료될 때마다, 즉 매 반복마다 **카운터 변수인 idx를 증가**시키는 용도로 사용됨
    - 증가를 시켜줘야 몇 번 반복했는지 셀 수 있음
    - 증가시키는 용도로 활용한다.

**[반복문을 중간에 조건식이 거짓이 되지 않았을 때에도 강제로 종료하는 법]**

- 반복문 block 내에서 if 조건문 사용


**[반복의 특정 회차 건너뛰는 방법]**

- if ~ continue
    - continue문을 만나게 되면 이 반복문 내의 다른 코드들은 실행하지 않고 바로 다음 반복 회차로 넘어가게 된다.

---
### 1.11) 함수

중복으로 작성된 코드들

- 생산성 떨어짐
- 향후 코드를 수정하거나 유지보수할 때 큰 문제가 될 수 있음

⇒ **함수로 해결 가능**


- 함수 선언: 함수를 새롭게 만드는 행위
    
    - 함수는 선언했다고 바로 실행되는 것이 아니고, 함수를 호출했을 때만 실행이 된다.
    - 함수 선언이라는 건 함수가 호출되었을 때 어떤 코드를 실행할 것인지 미리 준비해두는 작업
    - 함수를 호출할 때는 반드시 소괄호와 함께 호출해야 한다!
    - 함수가 호출되면 프로그램의 실행 순서가 함수 내부로 넘어간다.
        
        

**함수**


- 함수의 소괄호 안엔 변수 이름만 써줘도 됨
- 함수를 호출하면서 함수에게 전달한 값들을 각각 “인수”라고 부름
- 전달된 인수들을 순서대로 저장하는 특수한 함수의 변수들을 “매개변수”라고 부름, 매개채 역할을 하는 변수
- 함수를 호출하면서 10과 20이라는 인수를 전달해주면 전달된 인수는 함수의 매개변수의 순서대로 각각 10과 20이 저장이 된다.

- console.log 대신 return 사용 → 반환값(=함수 호출의 결과값) 존재 → 변수에 담아서 활용할 수 있음
    
    
    - return 문을 활용하면 함수가 어떠한 결과값을 반환하도록 만들어줄 수 있다.
    - 함수가 return 문을 만나게 되면 값을 반환하고 바로 종료가 된다 → return 문 밑에 코드를 추가적으로 작성하여도 그 코드는 실질적으로 실행이 되지 않는다.
- 자바스크립트는 함수 안에 또 다른 함수를 선언하는 것도 가능
    - 함수 안에 또 다른 함수를 중첩 함수라고 부름
    
    
- 자바스크립트에서는 함수 선언을 함수 호출보다 아래에 두어도 아무런 문제없이 잘 수행된다.
    - C나 Java처럼 선언이 되지 않은 함수를 미리 호출하려고 하면 오류를 발생시키는 게 일반적이지만 자바스크립트는 그렇지 않다. 정상적으로 실행이 된다.
    - 자바스크립트의 호이스팅이라는 기능 때문
        - 호이스팅 → 끌어올리다 라는 뜻
        - 자바스크립트에서의 호이스팅이란, 코드의 밑바닥에 작성된 선언문들을 코드를 실행하기 전에 코드의 최상단으로 끌어올려서 실행시켜주는 기능을 말한다. 그렇기 때문에 함수 선언문을 호출문보다 아래에 두어도 내부적으로 알아서 호이스팅되어서(끌어올려져서) 실행이 되기 때문에 아무런 문제가 발생하지 않는다.
        - 호이스팅 덕분에 함수 선언이 무조건 위에 있지 않아도 되기 때문에 좀 더 유연하게 프로그래밍을 진행할 수 있다.
---
### 1.12) 함수 표현식과 화살표 함수

1. **함수 표현식**


    - 함수도 숫자나 문자열과 같은 하나의 값으로써 취급하기 때문에 함수 자체를 변수에 담아놓을 수 있음
    - 어떤 함수를 변수에 담게 되면 함수를 변수의 이름으로 호출해줄 수 있음
    - 함수를 만들자마자 바로 변수에 담아버리는 것도 가능
    - 선언식이라는 것은 어떤 변수로써 담기지 않은 상태로 유지가 되어야 함
    - 값으로써 함수가 생성된 것임 → 함수의 이름으로 호출 불가 → 함수의 이름으로 못 부름 → 함수 이름 생략 → 이름이 없는 함수: 익명 함수
    - 함수 선언문을 이용해서 함수를 만들지 않고 대신 값으로써 함수를 생성하는 방식을 자바스크립트에서 함수 표현식이라고 부름
    - 함수 표현식으로 만든 함수들은 값으로써 취급이 되기 때문에 호이스팅이 되는 함수 선언문으로 만든 함수와 달리 함수 표현식으로 만든 함수들은 호이스팅의 대상이 되지 않는다.

2. **화살표 함수**

    - 함수를 이전보다 더 빠르고 간결하게 생성할 수 있도록 도와주는 자바스크립트 문법
    - function 지우고 소괄호와 대괄호 사이에 화살표 삽입
    - 값을 반환하기만 하는 함수일 때, 중괄호와 return 문을 지워도 됨
    - 매개변수가 필요하면 소괄호 안에 매개변수를 선언해주면 됨

---
### 1.13) 콜백함수

1. **콜백함수**

    콜백 함수(Callback Function)란?

    - 자신이 아닌 다른 함수에, 인수로써 전달된 함수를 의미함
    ```jsx
    // 1. 콜백함수
    function main(value) {
        console.log(1)
        console.log(2)
        value()
        console.log("end")
    }

    function sub() {
        console.log("i am sub")
    }

    main(sub)

    /*
    1
    2
    i am sub
    end
    */
    ```
    - sub 함수 → Callback 함수
    - 어떠한 함수를 다른 함수의 인수로 전달해서 나중에 호출시키도록, 해당 함수에서 알아서 호출하도록 설정한 sub와 같은 함수를 콜백함수라고 부름
    - 콜백 → 프로그래밍에서는 “뒷전에 실행되는” 또는 “나중에 실행되는”이라는 뜻으로 쓰임
    - 콜백함수는 메인함수가 언제든지 원하는 타이밍에 실행시킬 수 있다.

2. **콜백함수의 활용**
    -  콜백함수를 활용하면 중복코드를 발생시키지 않으면서 코드를 크게 개선할 수 있음

---
### 1.14) 스코프

**스코프(Scope)란?**

- 우리말로 “범위”를 뜻함
- 변수나 함수에 접근하거나 호출할 수 있는 범위를 말함


- 변수가 선언된 함수나 조건문이나 반복문 같은 중괄호를 이용해서 만들어진 블록 내부에서는 변수에 접근할 수 있지만, 그렇지 않은 영역에서는 접근할 수가 없다.
- 변수에 접근할 수 있는 영역을 스코프라고 부르고, 변수 a는 funcA라는 지역적인 스코프를 갖는다고 표현할 수 있다.
- 어떠한 함수나 반복문이나 조건문에 갇히지 않은 상태로, 완전히 바깥 위치에 변수를 선언하면 이 변수는 어디에서나 접근 가능해짐 → 전역 스코프를 갖는 변수가 됨
- 중괄호 안쪽을 블록이라고 부름
- 블록 내에 선언된 모든 변수들은 다 지역 스코프를 갖는다.
- 지역 스코프 → 외부(중괄호 바깥)에서 접근하려고 하면 오류 발생
- 반복문의 초기식에 선언된 변수도 지역 스코프를 갖기 때문에 반복문 외부에서는 접근할 수 없다.
- 함수도 변수처럼 지역 스코프를 가질 수 있다.
    - 예외적으로, **함수 선언식은 반복문이나 조건문 안에서는 지역 스코프를 갖지 않는다.**
    - 함수 선언식은 특별하게 함수 블록 안에서만 지역 스코프를 갖고, 나머지 for문이나 if문 안에서는 지역 스코프를 갖지 않는다.

---
### 1.15) 객체 1

**객체(Object)란?**

- 원시 타입이 아닌 객체 타입의 자료형
- 여러 가지 값을 동시에 저장할 수 있는 자료형을 의미


- 객체를 이용하면 현실세계에 존재하는 어떤 사물이나 개념을 표현하기 용이함


1. **객체 생성**

    1.1 객체 생성자라고 불리는 내장함수 사용 - new Object()

    1.2 빈 중괄호 → 객체 리터럴 (대부분 사용 - 간결하기 때문) - {}
    
    
2. **객체 프로퍼티 (객체 속성)**
    - key: value → key의 이름을 가지고 불리게 됨
    - 객체 안에 저장되어 있는 객체의 정보값들 → 객체 속성
    - 객체의 실질적인 정보를 담고 있는 역할
    - 프로퍼티의 개수에는 제한이 없음
    - value에 들어올 수 있는 자료형의 타입에도 제한이 없음
        - boolean, 함수, 객체 등등
    - key 값으로는 문자열이나 숫자만 이용 가능
    - 프로퍼티의 key로 사용되는 문자열에는 따옴표를 붙이지 않아도 되는데, 예외적으로 띄어쓰기가 포함된 문자열을 key로 사용하고자 한다면 이때에는 예외적으로 따옴표를 사용해야 한다.
    
    
3. **객체 프로퍼티를 다루는 방법**
    
    3.1. 특정 프로퍼티에 접근 (점 표기법, 괄호 표기법)
    
    - 점 표기법
        - key로 접근
        - value를 출력
        - 존재하지 않는 프로퍼티의 값을 꺼내오려고 하면 오류가 발생하지는 않고, undefined가 반환됨
    - 괄호 표기법
        - 대괄호 안에 접근하고자 하는 프로퍼티의 키를 명시
            - 쌍따옴표와 함께 문자열로 작성해야 함
            - 쌍따옴표 없이 작성 → 변수로 취급
        - 존재하지 않는 프로퍼티의 값을 꺼내오려고 하면 오류가 발생하지는 않고, undefined가 반환됨
        - 변수에 접근하고자 하는 key 값을 담아서 프로퍼티를 꺼내오도록 설정할 수 있기 때문에 동적으로 프로퍼티를 변화시키면서 꺼내와야 할 때, 괄호 표기법 이용, 그게 아니라면 문법이 훨씬 간결한 점 표기법을 이용하는 게 좋다.
    
    3.2 새로운 프로퍼티를 추가하는 방법
    
    ```jsx
    // 3.2 새로운 프로퍼티를 추가하는 방법
    person.job = "fe developer" 
    person["favoriteFood"] = "떡볶이"
    ```
    
    3.3 프로퍼티를 수정하는 방법
    
    ```jsx
    // 3.3 프로퍼티를 수정하는 방법
    person.job = "educator" 
    person["favoriteFood"] = "초콜릿"
    ```
    
    3.4 프로퍼티를 삭제하는 방법
    
    - delete라는 특별한 연산자를 이용
    - delete 연산자 뒤에 삭제하고자 하는 프로퍼티를 작성
    
    
    3.5 프로퍼티의 존재 유무를 확인하는 방법
    
    - in 연산자 이용
    - 특정 개체에 특정 프로퍼티가 존재하는지 유무를 알 수 있다.
    
---
### 1.16) 객체 2

1. **상수 객체**
    - 상수에 저장한 객체
    - 저장된 값을 바꿀 수 없음
    - 상수 객체에 다른 객체를 생성해서 할당하는 건 당연히 오류가 발생
    - 객체에 새로운 프로퍼티를 추가하거나 기존 객체에 들어있던 프로퍼티의 값을 수정하거나 객체 프로퍼티를 삭제하는 행위는 가능함
    - 상수에 저장된 객체도 프로퍼티를 추가하거나 수정하거나 삭제하는 게 가능 → 가능한 이유: 상수라는 건 엄밀히 말하자면 새로운 값을 할당하지 못하는 변수를 말함 → 아예 새로운 값을 할당하는 것은 문제가 되지만, 저장되어 있는 객체 값의 프로퍼티를 수정하는 건 아무런 문제가 되지 않는다. 그렇기 때문에 상수에 객체를 보관한다 하더라도 프로퍼티를 추가하거나 수정하거나 삭제하는 조작은 얼마든지 가능하다.
    

2. **메서드**
    - 객체 프로퍼티들 중에서 값이 함수인 프로퍼티를 말함
    - 메서드는 함수이기 때문에 당연히 호출하는 것 또한 가능
    - 메서드는 익명 함수로 만들 수도 있지만 화살표 함수로도 만들 수 있고 화살표 함수보다 더 단축된 형태로도 만들 수 있음
    - 메서드들은 어떻게 선언이 되든 점 표기법이나 괄호 표기법을 이용해서 호출을 할 수 있다.
    - 메서드는 보통, 객체의 동작을 정의하는 데 사용이 된다. → 함수가 아닌 프로퍼티들이 객체의 정보를 갖고 있다면, 함수 프로퍼티들은 메서드로써 객체의 동작을 정의한다.
    
---
### 1.17) 배열

**배열(Array)이란?**

- 여러 개의 값을 **순차적**으로 담을 수 있는 자료형
- 객체와 동일하게 여러 개의 값을 담을 수 있는 자료형
- 객체와의 차이점은 배열은 이 값들을 순차적으로 담는다.


1. **배열 생성**

    1.1 배열 생성자 - new Array()

    1.2 배열 리터럴 - []
    
    
    - 배열 안에는 어떤 타입의 값이든 자유롭게 다 넣을 수 있음
        - boolean, 문자열, null, undefined, 화살표 함수, 객체, 새로운 배열 등등
    - 길이의 한계도 없다.
    - 저장하고 싶은 데이터를 쉽게 순차적으로 보관할 수 있음
2. **배열 요소 접근**
    - 배열이라는 자료형은 순서대로 값을 저장하기 때문에 각각의 원소에 번호로 접근할 수 있다.
    - 인덱스: 배열의 원소 중에 몇 번째 원소를 가져오고 싶은지 의미하는 숫자
    - 배열의 인덱스, 즉 순서는 0부터 시작
    - 특정 원소의 값을 수정하는 것도 가능


---
## 섹션 3 - JavaScript 심화
### **2.1) Truthy와 Falsy**

- JavaScript는 어떠한 값이 boolean 타입에 해당하는 참이거나 거짓이지 않아도 상황에 따라서 참으로 판단하거나 거짓으로 판단하는 경우가 있다.


**Truthy & Falsy란?**

- 참이나 거짓을 의미하지 않는 값도, 조건문 내에서 참이나 거짓으로 평가하는 특징


**JavaScript의 모든 값은 Truthy 하거나 Falsy 하다**

- 이를 이용하면 조건문을 간결하게 만들 수 있음

1. **Falsy 한 값**
    - JavaScript에는 총 7가지의 Falsy 한 값 존재
    ```jsx
    // 1. Falsy 한 값
    let f1 = undefined
    let f2 = null
    let f3 = 0
    let f4 = -0
    let f5 = NaN
    let f6 = ""
    let f7 = 0n

    if (!f1) {
        console.log("falsy")    // falsy
    }
    ```
    - 조건문에서 거짓으로 평가됨
    - 0n → big integer라는 특수한 자료형에 해당하는 값
        - 아주 아주 큰 숫자를 저장하는데 사용되는 값
        - 보통 웹 개발 중에는 잘 이용하지 않음
    
    
2. **Truthy 한 값**
    - 7가지 Falsy 한 값들 제외한 나머지 모든 값
    
    

1. **활용 사례**
    - 변수가 undefined → undefined의 프로퍼티는 읽을 수 없음 → 오류 발생
    - 매개변수로 객체를 받을 것이라고 생각했는데 실제로는 undefined의 값이 들어오는 상황은 실제 서비스를 개발하다 보면 정말 자주 발생하는 상황 → 객체의 특정 프로퍼티에 접근하는 기능을 담고 있는 함수에서는 보통 조건문으로 매개변수의 값이 null이나 undefined이 아님을 먼저 확인해줘야 함
    - 복잡한 조건문 → 비효율적 ⇒ falsy를 이용해 조건문 개선

---
### **2.2) 단락 평가**

**단락 평가(Short-circuit Evaluation)란?**

- and나 or 같은 논리 연산식에서 첫 번째 피연산자 값만으로도 해당 연산의 결과를 확정할 수 있다면 두 번째 피연산자에는 접근조차 하지 않는 실행 방식


1. **AND 연산자**
    - 첫 번째 피연산자 값이 false라면 두 번째 피연산자 값이 무엇이든 항상 false
    - 첫 번째 값이 true라면 두 번째 값이 true인지 false인지에 따라 연산 결과가 달라지기 때문에 두 번째 값도 확인해야 함
2. **OR 연산자**
    - 첫 번째 피연산자 값이 true라면 두 번째 피연산자 값이 무엇이든 항상 ture
- 단락 평가를 이용하면 앞으로 조건문을 이용하지 않고도 특정 상황에서 어떠한 함수를 호출하지 않도록 방지하거나 어떠한 값들을 굳이 계산하지 않도록 제한하는 등의 아주 다양한 기능들을 개발할 수 있음
- 특정 조건에 맞춰서 함수를 아예 호출하지 않도록 방지할 수 있는 기능을 가지고 있다.
- 단락 평가는 true나 false와 같은 boolean 값 뿐만 아니라 Truthy한 값이나 Falsy한 값에도 당연히 적용이 된다.
    - 이때, 출력(연산의 결과값)되는 것은 true나 false가 아니라 **Truthy한 값** or **Falsy한 값 자체**


- **단락 평가 활용 사례**
    ```jsx
    // 단락 평가 활용 사례
    function printName(person) {
        const name = person && person.name
        console.log(name || "person의 값이 없음")
    }

    printName()     // person의 값이 없음
    printName({ name: "이정환" })    // 이정환
    ```
    - person 값이 있을 때
        - person이 true이기 때문에 person.name 확인 → **truthy && truthy**일 경우, **두 번째 truthy한 값** 저장
        - name || “person의 값이 없음” → **truthy || truthy**일 경우, **첫 번째 truthy한 값** 반환

---
### **2.3) 구조 분해 할당**

**구조 분해 할당이란?**

- 배열이나 객체에 저장된 여러 개의 값들을 말 그대로 분해해서 각각 다른 변수에 할당하는 문법
1. **배열**의 구조 분해 할당
    - 변수 개수가 배열의 원소 개수보다 적어도 괜찮음
        - 순서대로 할당
    - 변수 개수가 배열의 원소 개수보다 많을 경우, undefined 할당
        - 기본값 설정하는 것도 가능
    
    

2. **객체**의 구조 분해 할당
    - 각각 객체의 프로퍼티를 key 값을 기준으로 변수에 저장할 수 있다.
    - 객체의 구조 분해 할당은 배열의 구조 분해 할당과 다르게 객체를 상징하는 중괄호를 이용한다.
    - 존재하지 않는 프로퍼티를 구조 분해 할당으로 받으려고 하면 undefined이 저장된다.
        - 기본값을 설정하는 것 또한 배열의 구조 분해 할당과 동일하게 이루어진다.
    - 객체의 구조 분해 할당에서는 특별하게 할당받는 변수의 이름을 변경할 수 있음
        - 구조 분해로 할당 받는 변수 이름 : 내가 원하는 변수 이름
    
    
3. **객체 구조 분해 할당**을 이용해서 **함수의 매개변수**를 받는 방법
    - 객체 구조 분해 할당은 함수에 여러 개의 인수를 전달할 때 꽤나 자주 사용이 된다.
    - 객체를 넘겼을 때만, 중괄호와 함께 구조 분해 할당을 받을 수 있다.
    - 매개변수 정의 시, 중괄호를 사용해서 구조 분해 할당이라는 것을 명시해줘야 한다.


---
### **2.4) Spread 연산자와 Rest 매개변수**

1. **Spread 연산자 (…)**
    - Spread : 흩뿌리다, 펼치다 라는 뜻
        - 해당 객체나 배열의 모든 원소를 풀어헤쳐라
    - 객체나 배열에 저장된 여러 개의 값을 개별로 흩뿌려주는 역할
    - 다른 배열에 내가 원하는 배열을 인덱스를 사용하여 직접 넣는 것은 위험함 → 원하는 배열에 나중에 원소가 추가될 수도 있고 삭제가 될 수도 있기 때문
        - 원래 배열이라는 건 중간에 값을 바꿔가면서 쓰려고 사용함
        - 인덱스로 배열을 일일이 채워 넣는 건 위험한 방법!
        
        ⇒ Spread 연산자를 사용하여 안전하고 편하게 배열의 값들을 펼쳐 놓을 수 있다.
        
    - 함수를 호출할 때도 spread 연산자를 자주 활용한다.
        - 함수를 호출하면서 인수로 객체나 배열의 값을 순서대로 전달하고 싶을 때, spread 연산자로 풀어헤쳐서 전달하면 된다.
    

2. **Rest 매개변수 (…)**
    - Rest는 나머지, 나머지 매개변수
    - 여러 개의 매개변수를 받아야 할 때, 배열 형태로 한 번에 여러 개의 매개변수를 받아올 수 있도록 해주는 문법
    - “…”이 매개변수를 정의하는 공간인 소괄호 안에 사용되었기 때문에 spread 연산자가 아니라 rest 매개변수임! 둘은 엄연히 다름!!
    - Rest 매개변수를 이용하면 매개변수가 아무리 많이 들어온다고 하더라도 배열에 한 번에 다 저장해 놓을 수 있기 때문에 굉장히 편리함
    - 첫 번째 매개변수는 다른 이름으로 받고 싶다 → 첫 번째에 원하는 매개변수를 적으면 됨 → 첫 번째 이후에 전달되는 인수들이 배열에 저장된다.
    - Rest 매개변수 뒤에는 추가적으로 매개변수를 더 선언할 수 없다.
        - Rest 매개변수는 지금부터 나오는 뒤의 모든 인수들을 다 배열에 저장하는 기능을 하기 때문
        - 반드시 rest 매개변수가 마지막에 오도록 설정해야 한다.

---
### **2.5) 원시타입 VS 객체타입**

- JavaScript의 타입은 크게 원시타입과 객체타입으로 나누어진다.


- 모든 타입들을 굳이 원시타입과 객체타입이라는 두 가지로 구분하는 이유는 바로 원시타입과 객체타입은 값이 저장되거나 복사되는 과정이 서로 다르기 때문


**원시타입 VS 객체타입**


1. **원시타입**
    - 값 자체로써 변수에 저장되고 복사된다.
    
    ```jsx
    let p1 = 1     // 첫 번째 줄
    let p2 = p1    // 두 번째 줄
    
    p2 = 2
    ```
    
    - 첫 번째 줄
        - 1이라는 값을 메모리 어디인가에 저장 → p1이라는 변수를 만들어서 이 메모리 공간을 가리키게 만듦 → 이렇게 함으로써 변수가 실제 값을 가지게 됨
    - 두 번째 줄
        - p2도 동일하게 먼저 새로운 메모리 공간에 1이라는 값을 저장하고 p2라는 변수를 생성한 다음에 방금 만든 새로운 공간을 가리키도록 동작을 하게 됨
        - p2의 값을 2로 변경시키는 코드가 추가로 실행이 되면, 현재 메모리 공간에 2라는 값이 없기 때문에 2라는 값을 새로운 메모리 공간에 저장하고 p2라는 변수가 해당 메모리 공간을 가리키게 됨.
    - 변수의 값을 1에서 2로 변경을 하게 되더라도 실제 메모리의 값은 수정되지 않음.
    - 대신 변경해야 될 값을 새로운 메모리 공간에 추가적으로 저장하고 이어서 변수가 1을 가리키던 걸 2를 가리키도록 동작하게 됨.
    - 그렇기 때문에 원시 타입의 값들은 값이 저장되고 복사되고 변경되는 과정에서 변수의 값이 1에서 2로 변경되더라도 메모리에 한 번 저장해두었던 원본 데이터가 수정되지는 않기 때문에 원시타입의 값들을 **불변값**이라고 부르기도 함.
        - 이때 오해하면 안 되는 게 변수의 값을 바꿀 수 없어서, 상수여서 불변이라는 게 아니고! **실제로 메모리 공간에 저장된 원본 데이터의 값은 변경되지 않는다**라는 의미의 불변임.
    
    

1. **객체타입**
    - 값 자체가 아닌 값에 접근할 수 있는 주소값인 참조값이라고 불리는 특별한 값을 통해서 변수에 저장되고 복사된다.
    
    ```jsx
    let o1 = { name: "이정환" }
    let o2 = o1
    
    o2.name = "홍길동"
    ```
    
    - 메모리에 객체를 저장하고 변수를 이 값을 가리키도록 하면 될 것 같지만 그렇게 동작하지 않는다. → 메모리 어딘가에 객체를 따로 저장해둔 다음, 변수 o1에는 객체값이 저장된 메모리 공간을 가리키는 주소값인 참조값을 저장하게 된다.
        - 참고로, 객체타입의 값들을 이러한 방식으로 저장하는 이유는 객체타입의 값들은 원시타입의 값들과는 다르게 배열이나 객체처럼 여러 개의 값을 저장함과 동시에 저장하는 값의 개수가 동적으로 늘어났다가 줄어들었다가 하기 때문에 별도의 메모리 공간에 보관하는 것임.
    - o1, o2 → 두 변수가 모두 같은 참조값을 가리키는 상태가 됨.
    - o2 객체의 name 프로퍼티 값을 “홍길동”으로 바꾸는 코드를 추가 → 원시타입이었다면 새로운 객체를 생성해서 메모리에 저장하고 o2가 생성된 객체를 가리키도록 동작했겠지만, 객체타입은 그렇지 않고 o2 변수가 가리키고 있던 값을 메모리 상에서 수정해버린다. 즉, **원본 데이터를 수정**해버린다. 그래서 이렇게 될 경우에는 변수 o2의 값만 바뀌는 게 아니라 o1의 값도 함께 바뀌어 버리게 된다. 그래서 객체타입의 값들은 원시타입의 값들과는 다르게 메모리 상에서 아예 값이 수정되기 때문에 **가변값**이라고 부름.
    

- 결론적으로, 원시타입과 객체타입의 차이는, **원시타입**의 경우에는 값 자체로써 변수에 저장되고 복사되기 때문에 변수의 값을 수정하더라도 메모리에 저장된 원본 데이터는 수정되지 않기 때문에 이러한 값들을 불변값이라고 부르는 반면, **객체타입**의 경우에는 값은 별도의 메모리 공간에 따로 보관해두고 참조값을 통해서 변수에 저장되고 복사되기 때문에 특정 프로퍼티의 값을 수정하게 되면 메모리에 저장된 원본 데이터 자체가 수정되어서 이러한 객체타입의 값들을 가변값이라고 부른다.
    
    

**객체 타입 주의사항**

1. 의도치 않게 값이 수정될 수 있다.
    
    ```jsx
    let o1 = { name: "이정환" }
    
    // 대입 연산자
    let o2 = o1      
    
    // Spread 연산자
    let o2 = { ...o1 }
    ```
    
    - Side Effect : 우리가 의도하지 않았는데 하나의 변화가 또 다른 변수에 변화를 가져오는 것
    - 객체의 값을 복사할 때는 대입 연산자로 변수의 이름을 써줘서 변수의 참조값 자체를 복사 X → **새로운 객체를 생성**하고 그 내부에 **spread 연산자 등을 이용**해서 새로운 객체를 생성하면서 내부 프로퍼티만 따로 복사해오는 방식으로 객체를 복사해와야 함
        
        ⇒ 새로운 참조값에 새로운 객체로 따로 저장이 된다.
        
        
        - 이렇게 했을 때, o2의 name 프로퍼티를 변경시킨다고 하더라도 변수 o1과 변수 o2는 서로 다른 참조값을 갖는 객체이기 때문에 변수 o2의 값만 바뀌고 변수 o1의 값은 변경되지 않는다. 그래서 **안전하게 객체의 값을 수정**할 수 있다.
        
        
    
    - 객체의 참조값을 그대로 대입 연산자를 통해 복사하는 방식을 **얕은 복사**라고 부르고, 반대로 새로운 객체를 생성하면서 프로퍼티만 따로 spread 연산자 같은 걸로 복사해주는 방식을 **깊은 복사**라고 함
    - **얕은 복사**는 원본 객체가 수정되어버리는 상황이 발생할 수 있어서 위험할 수 있는 상황이 많이 발생할 수 있는 방식
    - **깊은 복사**는 원본 객체랑은 다른 새로운 객체를 만들어내는 방식으로 동작하는 것이기 때문에 원본 객체 자체가 수정될 일이 없어서 **비교적 훨씬 더 안전**한 방식이다.
    
    
2. 객체 간의 비교는 기본적으로 참조값을 기준으로 이루어진다.
    
    ```jsx
    let o1 = { name: "이정환" }
    let o2 = o1
    let o3 = { ...o1 }
    
    console.log(o1 === o2)   // true
    console.log(o1 === o3)   // false
    ```
    
    - 가지고 있는 프로퍼티로의 구조로만 보자면 o1과 o3는 같은 객체는 맞다. 그러나 객체 간의 비교 연산은 기본적으로 참조값을 기준으로 이루어지기 때문에 false가 나옴.
        - 참조값이 서로 다른 두 객체이기 때문에 서로 다르다고 평가하게 된다.
    
    
    - 참조값이 아닌 프로퍼티를 기준으로 두 객체를 비교하고 싶다면 JSON.stringify()와 같은, 객체를 문자열로 형 변환하는 내장 함수를 이용해서 참조값이 아닌 프로퍼티를 기준으로 비교하도록 설정해줘야 한다.
        - JSON.stringify()
            - 자바스크립트의 내장 함수
            - 객체를 문자열로 변환하는 기능
    
    
    - 동등 연산자를 이용한 비교는 참조값을 기준으로 비교하기 때문에 **얕은 비교**라고 부르고, JSON.stringify() 같은 내장 함수를 사용해서 객체 자체를 문자열로 변환해서 비교하는 방식은 프로퍼티 값들을 기준으로 비교하기 때문에 **깊은 비교**라고 부르게 된다.
        - 객체값을 서로 비교할 때
            - 객체의 참조값이 같은지 비교할 때는 얕은 비교를 수행
            - 프로퍼티 값을 기준으로 비교하려고 하는 거라면 깊은 비교를 수행

    

3. 배열과 함수도 사실 객체이다
    
    
    - JavaScript의 배열과 함수는 특수한 객체들이기 때문에 배열과 함수 또한 일반 객체에 존재하는 프로퍼티와 메서드를 다 가지고 있다.
        - 배열과 함수는 사실 객체였고, 그러므로 추가적인 프로퍼티와 메서드를 가질 수 있다라는 사실까지만 알아두기! → 자세한 내용들은 향후 수업에서 다룸


---
### **2.6) 반복문으로 배열과 객체 순회하기**

**순회(Iteration)란?**

- 배열, 객체에 저장된 여러 개의 값에 순서대로 하나씩 접근하는 것을 말함
    - ex) 배열 순회
        
        ```jsx
        let numbers = [1, 2, 3]
        ```
        
    - ex) 객체 순회
        
        ```jsx
        let person = {
        	name: "이정환",
        	age: 27,
        	hobby: "테니스",
        }
        ```
    

1. **배열 순회**
    
    1.1 배열 인덱스
    
    ```jsx
    // 1.1 배열 인덱스
    for (let i = 0; i < arr.length; i++) {
        console.log(arr[i])
    } 
    /*
    1
    2
    3
    */
    
    let arr2 = [4, 5, 6, 7, 8]
    for (let i = 0; i < arr2.length; i++) {
        console.log(arr2[i])
    }
    ```
    
    - length라는 프로퍼티
        - 배열의 길이를 저장하고 있는 프로퍼티
        - 모든 배열이 다 가지고 있는 프로퍼티
    - 배열이나 객체도 함수이기 때문에 프로퍼티나 메서드를 가질 수 있다.
    - for문을 이용하면 특정 배열을 순회할 수 있다.
    - 카운터 변수에 인덱스가 저장되기 때문에 인덱스를 통한 활동을 할 수 있다.
    
    1.2 for of 반복문
    
    ```jsx
    // 1.2 for of 반복문
    for (let item of arr) {
        console.log(item)
    }
    ```
    
    - 오직 배열을 순회하기 위해서만 존재하는 특수한 반복문
    - 인덱스를 저장하지 않고 배열 안에 있는 값들을 순서대로 순회만 해줌 → 인덱스 활용 X
    
2. **객체 순회**
    
    2.1 Object.keys 사용 
    
    - 객체에서 key 값들만 뽑아서 새로운 배열로 반환해주는 내장함수
    
    ```jsx
    // 2.1 Object.keys 사용
    // -> 객체에서 key 값들만 뽑아서 새로운 배열로 반환
    let keys = Object.keys(person)
    // console.log(keys)   // ['name', 'age', 'hobby']
    
    for (let i = 0; i < keys.length; i++) {
        console.log(keys)
    }
    
    for (let key of keys) {
        const value = person[key]
        console.log(key, value)
    }
    ```
    
    2.2 Object.values 사용
    
    - 객체에서 value 값들만 뽑아서 새로운 배열로 반환
    
    ```jsx
    // 2.2 Object.values 사용
    // -> 객체에서 value 값들만 뽑아서 새로운 배열로 반환
    let values = Object.values(person)
    // console.log(values)   // ['이정환', 27, '테니스']
    
    for (let value of values) {
        console.log(value)
    }
    ```
    
    2.3 for in
    
    - 객체만을 위해 존재하는 특수한 반복문
    
    ```jsx
    // 2.3 for in 
    for (let key in person) {
        const value = person[key]
        console.log(key, value)
    }
    ```
    
    **※주의※**
    
    **for of** → **배열**에만 사용 가능, **for in** → **객체**에만 사용 가능



---
### **2.7) 배열 메서드 1. 요소 조작**

**6가지의 요소 조작 메서드**

1. **push**
    - 배열의 맨 뒤에 새로운 요소를 추가하는 메서드
    - 요소들을 추가하고 난 다음에 변환된 배열의 길이를 반환한다.
    
    ```jsx
    // 1. push 
    // 배열의 맨 뒤에 새로운 요소를 추가하는 메서드
    let arr1 = [1, 2, 3]
    const newLength = arr1.push(4, 5, 6, 7)
    
    console.log(arr1)       // [1, 2, 3, 4, 5, 6, 7]
    console.log(newLength)  // 7
    ```
    
2. **pop**
    - 배열의 맨 뒤에 있는 요소를 제거하고, 반환
    
    ```jsx
    // 2. pop
    // 배열의 맨 뒤에 있는 요소를 제거하고, 반환
    let arr2 = [1, 2, 3]
    const popedItem = arr2.pop()
    
    console.log(popedItem)  // 3
    console.log(arr2)       // [1, 2]
    ```
    
3. **shift**
    - 배열의 맨 앞에 있는 요소를 제거, 반환
    
    ```jsx
    // 3. shift
    // 배열의 맨 앞에 있는 요소를 제거, 반환
    let arr3 = [1, 2, 3]
    const shiftedItem = arr3.shift()
    console.log(shiftedItem, arr3)  // 1 [2, 3]
    ```
    
4. **unshift**
    - 배열의 맨 앞에 새로운 요소를 추가하는 메서드
    - push처럼 요소들을 추가하고 난 다음에 변환된 배열의 길이를 반환한다.
    
    ```jsx
    // 4. unshift
    // 배열의 맨 앞에 새로운 요소를 추가하는 메서드
    let arr4 = [1, 2, 3]
    const newLength2 = arr4.unshift(0)
    console.log(newLength2, arr4)   // 4 [0, 1, 2, 3]
    ```
    

- **shift & unshift** → push & pop보다 **비교적 느리게 동작**
    - 인덱스를 한칸씩 옮겨야 함
    - 비효율적인 방식으로 동작
    - 되도록이면 push & pop을 통해 해결하는 게 좋다.

5. **slice**
       
    - 마치 가위처럼, 배열의 특정 범위를 잘라내서 새로운 배열로 반환

    ```jsx
    // 5. slice
    // 마치 가위처럼, 배열의 특정 범위를 잘라내서 새로운 배열로 반환
    let arr5 = [1, 2, 3, 4, 5]
    let sliced = arr5.slice(2, 5)
    let sliced2 = arr5.slice(2)
    let sliced3 = arr5.slice(-2)    // 뒤에서부터 2개 잘라라
    console.log(sliced)     // [3, 4, 5]
    console.log(sliced2)    // [3, 4, 5]
    console.log(sliced3)    // [4, 5]
    ```
    
    - slice(자르기 시작하는 인덱스, 잘라낼 범위의 끝의 인덱스 + 1)
    - 원본 배열의 값은 변하지 않는다.
    - 두 번째 인수를 생략하면 끝까지 자르라는 뜻
    - 뒤에서부터 자르고 싶다 → 음수 사용
    
6. **concat**
    - 두 개의 서로 다른 배열을 이어 붙여서 새로운 배열을 반환
    ```jsx
    // 6. concat
    // 두 개의 서로 다른 배열을 이어 붙여서 새로운 배열을 반환
    let arr6 = [1, 2]
    let arr7 = [3, 4]

    let concatedArr = arr6.concat(arr7) // arr6 뒤에 arr7 배열이 붙어서 새로운 배열로 반환
    console.log(concatedArr)    // [1, 2, 3, 4]
    ```


---
### **2.8) 배열 메서드 2. 순회와 탐색**

**5가지 요소 순회 및 탐색 메서드**

1. **forEach**
    - 모든 요소를 순회하면서, 각각의 요소에 특정 동작을 수행시키는 메서드
    - 배열의 요소들을 마치 반복문처럼 순회하면서 매 반복마다 콜백함수를 호출하고 매개변수로 현재 요소의 값과 현재 반복 카운트와 전체 배열의 값을 전달해주게 된다.
    - 콜백함수는 배열의 요소의 개수만큼 호출이 된다.
    - 배열의 요소들을 순회하면서 콜백함수로 해당 요소를 가지고 다양한 동작들을 수행하도록 만들어줄 수 있어서 앞으로도 우리가 꽤나 자주 이용하게 될 메서드이다.
    
    ```jsx
    // 1. forEach
    // 모든 요소를 순회하면서, 각각의 요소에 특정 동작을 수행시키는 메서드
    let arr1 = [1, 2, 3]
    
    arr1.forEach(function (item, idx, arr) {
        console.log(idx, item * 2)
    })
    /*
    0 2
    1 4
    2 6
    */
    
    let doubleArr = []
    arr1.forEach((item) => {
        doubleArr.push(item * 2)
    })
    console.log(doubleArr)  // [2, 4, 6]
    ```
    

2. **includes**
    - 배열에 특정 요소가 있는지 확인하는 메서드
    
    ```jsx
    // 2. includes
    // 배열에 특정 요소가 있는지 확인하는 메서드
    let arr2 = [1, 2, 3]
    let isInclude = arr2.includes(10)
    
    console.log(isInclude)  // false
    ```
    

3. **indexOf**
    - 특정 요소의 인덱스(위치)를 찾아서 반환하는 메서드
    - 찾으려는 요소가 배열에 **여러 개 존재**한다면, indexOf는 배열의 앞에서부터 탐색을 시작하기 때문에 **가장 첫 번째로 찾아낸 요소의 인덱스**를 반환하게 됨
    - **존재하지 않는 요소의 인덱스** → 존재하지 않는다는 의미로 **-1** 반환
    
    ```jsx
    // 3. indexOf
    // 특정 요소의 인덱스(위치)를 찾아서 반환하는 메서드
    let arr3 = [1, 2, 3]
    let arr3_2 = [2, 2, 2]
    let index = arr3.indexOf(2)
    let index2 = arr3_2.indexOf(2)
    let index3 = arr3_2.indexOf(20)
    console.log(index)   // 1
    console.log(index2)  // 0
    console.log(index3)  // -1
    ```
    

4. **findIndex**
    - 모든 요소를 순회하면서, 콜백함수를 만족하는 그런 특정 요소의 인덱스(위치)를 반환하는 메서드
    - 순회하면서 가장 처음으로 콜백함수를 만족하는 요소의 위치를 찾아서 그 요소의 인덱스를 반환
    - 화살표 함수보다 더 간단한 표현식 → 함수가 연산식의 결과를 반환함 - true or false → item의 값이 2로 나누어 떨어지지 않을 때 true 반환하고 그렇지 않을 때는 false를 반환
    - 조건문을 만족하는 요소가 배열에 존재하지 않는다면, -1 반환
    - findIndex가 존재하는 이유
        - indexOf라는 메서드는 배열에 원시타입의 값이 들어있을 때가 아니라 객체타입의 값들이 저장된 배열에서는 정확한 요소의 위치를 찾아낼 수 없기 때문
            - indexOf는 기본적으로 얕은 비교로 동작 → 동등 비교 연산자(===)로 비교
            - 객체값들은 참조값을 기준으로 비교된다.
            - 프로퍼티를 기준으로 비교가 이루어지지 않는다.
            - 그렇기 때문에 indexOf로는 배열에서 특정 개체값이 존재하는지는 찾아낼 수 없다.
        - ⇒ 이럴 때 findIndex 이용!
        - findIndex는 콜백함수를 이용해서 우리가 직접 특정 프로퍼티의 값을 기준으로 비교시킬 수 있기 때문에 복잡한 객체값도 조건식만 잘 만들어주면 쉽게 찾아낼 수 있다는 장점이 있다.
        - 단순한 원시타입의 값을 찾을 때는 indexOf, 복잡한 객체 타입의 값을 찾을 땐 findIndex를 쓰면 좋다.
    
    ```jsx
    // 4. findIndex
    // 모든 요소를 순회하면서, 콜백함수를 만족하는 그런
    // 특정 요소의 인덱스(위치)를 반환하는 메서드
    let arr4 = [1, 2, 3]
    const findedIndex = arr4.findIndex((item) => {
        if (item % 2 !== 0) return true
    })
    
    // 화살표 함수를 더 간단하게
    const findedIndex2 = arr4.findIndex((item) => item % 2 !== 0)
    
    console.log(findedIndex)    // 0
    
    let objectArr = [
        { name: "이정환"},
        { name: "홍길동"},
    ]
    
    console.log(
        objectArr.indexOf({ name: "이정환"})    // -1
    ) 
    
    console.log(
        objectArr.findIndex(
            (item) => item.name === "이정환"    // 0
        )
    )
    ```
    

5. **find**
    - 모든 요소를 순회하면서 콜백함수를 만족하는 요소를 찾는데, 요소를 그대로 반환
    ```jsx
    // 5. find
    // 모든 요소를 순회하면서 콜백함수를 만족하는 요소를 찾는데, 요소를 그대로 반환

    let arr5 = [
        { name: "이정환"},
        { name: "홍길동"},
    ]

    const finded = arr5.find(
        (item) => item.name === "이정환"
    )

    console.log(finded)     // {name: '이정환'}
    ```


---
### **2.9) 배열 메서드 3. 배열 변형**

**5가지 배열 변형 메서드**

1. **fileter**
    - 기존 배열에서 조건을 만족하는 요소들만 필터링하여 새로운 배열로 반환
    - find나 findIndex 메서드처럼 콜백함수를 이용해서 배열의 **모든 요소들을 순회**하면서 **조건을 만족하는 값들만 새로운 배열**로 반환
    - 웹서비스를 개발할 때, 특정 조건에 의해서 검색시키는 기능이나 카테고리별 필터 기능을 만드는데 거의 필수적으로 사용된다.
    - 매개변수로 item, idx, arr을 전달 받는다.
    
    ```jsx
    // 1. filter
    // 기존 배열에서 조건을 만족하는 요소들만 필터링하여 새로운 배열로 반환
    
    let arr1 = [
        { name: "이정환", hobby: "테니스"},
        { name: "김효빈", hobby: "테니스"},
        { name: "홍길동", hobby: "독서"},
    ]
    
    const tennisPeople = arr1.filter(
        (item) => item.hobby === "테니스"
    )
    
    console.log(tennisPeople)
    /*
    0
    : 
    {name: '이정환', hobby: '테니스'}
    1
    : 
    {name: '김효빈', hobby: '테니스'}
    length
    : 
    2
    [[Prototype]]
    : 
    Array(0)
    */
    ```
    

2. **map**
    - 배열의 모든 요소를 순회하면서, 각각 콜백함수를 실행하고 그 결과값들을 모아서 새로운 배열로 반환
    - 프론트 분야에서 뗄레야 뗄 수 없을 정도로 자주 활용되는 메서드
    - forEach 메서드와 동일하게 동작하나, 콜백함수 안에서 반환값을 설정해줄 수도 있다.
    - 원본 배열의 값들을 변형한 새로운 배열을 생성할 수 있다.
    
    ```jsx
    // 2. map
    // 배열의 모든 요소를 순회하면서, 각각 콜백함수를 실행하고 그 결과값들을 모아서 새로운 배열로 반환
    let arr2 = [1, 2, 3]
    const mapResult1 = arr2.map((item, idx, arr) => {
        return item * 2
    })
    console.log(mapResult1)     // [2, 4, 6]
    
    let names = arr1.map((item) => item.name)
    console.log(names)      // ['이정환', '김효빈', '홍길동']
    ```
    

3. **sort**
    - 배열을 **사전 순으로 정렬**하는 메서드
    - 배열의 값이 문자열로 이루어져 있는 게 아니라, 숫자값으로 이루어진 배열이라면 sort 메서드가 정상적으로 동작하지 않는다.
        - 숫자의 대소 비교를 통해 정렬 X → 사전 순으로 정렬
        - 숫자의 대소 관계를 통해 정렬하고 싶다면, sort 메서드를 호출하면서 비교 기준을 설정하는 콜백함수도 함께 넘겨줘야 한다.
        - 콜백함수에서는 두 개의 배열 요소를 a와 b로 받아서 두 개의 배열 요소를 비교할 때 뭐가 더 크고 뭐가 더 작은 값이라고 판단할 건지 이 함수 안에 다 설정해줘야 한다.
            - if 조건문에서 **양수** 반환 → **a를 b 뒤로 정렬**
            - **음수** 반환 → **a를 b 앞으로 정렬**
            - **0** 반환 → a, b 자리를 **그대로 유지**
    
    ```jsx
    // 3. sort
    // 배열을 사전 순으로 정렬하는 메서드
    let arr3 = ["b", "a", "c"]
    let arrNumber = [10, 3, 5]
    arr3.sort()
    arrNumber.sort()
    
    console.log(arr3)         // ['a', 'b', 'c']
    console.log(arrNumber)    // [10, 3, 5]
    
    // 오름차순
    arrNumber.sort((a, b) => {
        if (a > b) {
            // b가 a 앞에 와라
            return 1    // -> b, a 배치
        } else if (a < b) {
            // a가 b 앞에 와라
            return -1   // -> a, b 배치
        } else {
            // 두 값의 자리를 바꾸지 마라
            return 0    // -> a, b 자리를 그대로 유지
        }
    })
    
    console.log(arrNumber)    // [3, 5, 10]
    
    // 내림차순 
    arrNumber.sort((a, b) => {
        if (a > b) {
            // b가 a 앞에 와라
            return -1    // -> a, b 배치
        } else if (a < b) {
            // a가 b 앞에 와라
            return 1   // -> b, a 배치
        } else {
            // 두 값의 자리를 바꾸지 마라
            return 0    // -> a, b 자리를 그대로 유지
        }
    })
    
    console.log(arrNumber)    // [10, 5, 3]
    
    ```
    

4. **toSorted**
    - sort와 똑같이 배열을 사전 순으로 정렬
    - sort는 원본 배열 자체를 정렬시키는 메서드이지만, toSorted 메서드는 원본 배열은 놔두고 정렬된 새로운 배열을 반환하는 메서드
    - 가장 최근에 추가된 최신 함수
    
    ```jsx
    // 4. toSorted (가장 최근에 추가된 최신 함수)
    // 정렬된 새로운 배열을 반환하는 메서드
    let arr5 = ["c", "a", "b"]
    const sorted = arr5.toSorted()
    
    console.log(arr5)   // ['c', 'a', 'b']
    console.log(sorted) // ['a', 'b', 'c']
    ```
    

5. **join**
    - 배열의 모든 요소를 하나의 문자열로 합쳐서 반환하는 메서드
    - 콤마 = seperator(구분자): 배열의 요소와 요소 사이에 들어가는 문자 → 기본이 콤마
    - 구분자를 바꾸고 싶다면 join 메서드의 인수로 바꾸고 싶은 구분자를 넣으면 된다.
        - “-”
        - “|”
        - “”(빈 문자열)
        - “ “(공백)
    ```jsx
    // 5. join
    // 배열의 모든 요소를 하나의 문자열로 합쳐서 반환하는 메서드
    let arr6 = ["hi", "im", "winterlood"]
    const joined = arr6.join()
    console.log(joined)   // hi,im,winterlood
    ```


---
### **2.10) Date 객체와 날짜**

1. **Date 객체를 생성**하는 방법
    - new라는 키워드와 함께 새로운 객체를 생성하는 내장함수들을 생성자라고 부름
    - Date 객체는 생성자 함수에 아무런 인수를 전달하지 않고 생성하게 되면 현재 지금 시간을 저장하는 date 객체로 생성이 된다.
    - 특정 날짜나 특정 시간을 기준으로 새롭게 생성하고 싶다면, 생성자에 인수로 특정 날짜를 넣어주면 된다.
        - 문자열로 명시한 날짜의 형식은 대시(-), 점(.), 슬래시(/) 사용 가능
        - 시간은 “시:분:초” 형식
    - 인수로는 문자열 말고 숫자도 가능(콤마로 구분)
        - JavaScript의 Date 객체에서 월(month)을 나타내는 숫자는 0부터 시작하는 인덱스 체계를 사용 → ex) 1을 입력했을 때 2월(February)이 출력
    
    ```jsx
    // 1. Date 객체를 생성하는 방법
    let date1 = new Date()  // 생성자
    console.log(date1)  // Thu Dec 19 2024 01:31:53 GMT+0900 (한국 표준시)
    
    let date2 = new Date("1997-01-07")
    console.log(date2)  // Tue Jan 07 1997 09:00:00 GMT+0900 (한국 표준시)
    
    let date2_time = new Date("1997/01/07/10:10:10")
    console.log(date2_time) // Tue Jan 07 1997 10:10:10 GMT+0900 (한국 표준시)
    
    let date2_number = new Date(1997, 1, 7, 23, 59, 59)
    console.log(date2_number)   // Fri Feb 07 1997 23:59:59 GMT+0900 (한국 표준시)
    ```
    

2. **타임 스탬프**
    - 특정 시간이 “1970.01.01 00시 00분 00초”로부터 몇 ms가 지났는지를 의미하는 숫자값
        - 기준이 되는 시각(“1970.01.01 00시 00분 00초”): 협정 세계시, UTC → 세계 모든 나라가 표준으로 사용하는 시간이 시작되는 지점
    - 복잡한 시간 정보를 숫자로 관리할 수 있도록 해주기 때문에 굉장히 편리해서 이곳저곳에 자주 사용이 된다.
    - getTime 이라는 메서드는 date 객체 안에 저장되어 있는 시간에 해당하는 타임 스탬프를 계산해서 반환해준다.
    - 새로운 date 객체를 생성하는 데에도 이용된다.
        - 새로운 date 객체를 생성하면서 인수로 타임 스탬프 값을 전달해주게 되면, 타임 스탬프에 해당하는 시간으로 date 객체가 생성된다.
    - 꽤나 복잡한 형태를 가지고 있는 시간 정보를 간단한 숫자로 표현할 수 있기 때문에 서비스를 개발하는 과정에서도 타임 스탬프가 자주 사용이 된다.
    
    ```jsx
    // 2. 타임 스탬프
    let ts1 = date1.getTime()
    console.log(ts1)
    
    let date3 = new Date(ts1)
    console.log(date1, date3)   // Thu Dec 19 2024 01:49:38 GMT+0900 (한국 표준시) Thu Dec 19 2024 01:49:38 GMT+0900 (한국 표준시)
    ```
    

3. **시간 요소들을 추출하는 방법**
    
    ```jsx
    // 3. 시간 요소들을 추출하는 방법
    let year = date1.getFullYear()
    let month = date1.getMonth() + 1    // js의 월은 0부터 시작하기 때문
    let date = date1.getDate()
    
    let hour = date1.getHours()
    let minute = date1.getMinutes()
    let seconds = date1.getSeconds()
    
    console.log(
        year,
        month,
        date,
        hour,
        minute,
        seconds
    )
    /*
    2024 12 19 1 57 15
    */
    ```
    

4. **시간 수정하기**
    - 수정하고 싶은 숫자를 인수로 넘겨주면 된다.
    
    ```jsx
    // 4. 시간 수정하기
    date1.setFullYear(2023)
    date1.setMonth(2)
    date1.setDate(30)
    date1.setHours(23)
    date1.setMinutes(59)
    date1.setSeconds(59)
    
    console.log(date1)    // Thu Mar 30 2023 23:59:59 GMT+0900 (한국 표준시)
    ```
    

5. **시간을 여러 포맷으로 출력하기**
    - 시, 분, 초를 제외하고 날짜만 출력 → toDateString()
    - 영어 포맷 말고 우리나라에서 사용하는 현지화된 포맷으로 출력 → toLocaleString()
        - toLocaleString 메서드에 인수를 넣지 않으면 시스템의 기본 로케일 설정을 따라 출력된다.
        - 우리나라에서 사용하는 컴퓨터나 브라우저의 경우, 대부분 한국어(ko-KR) 로케일이 기본으로 설정되어 있기 때문에 한국 형식으로 출력된다.

    ```jsx
    // 5. 시간을 여러 포맷으로 출력하기
    console.log(date1.toDateString())     // Thu Mar 30 2023
    console.log(date1.toLocaleString())   // 2023. 3. 30. 오후 11:59:59
    ```



---
### **2.11) 동기와 비동기**

1. **동기란 무엇일까?**
    - 여러 개의 작업을 순서대로 한번에 하나씩 처리하는 방식

    - **쓰레드(Thread)**: 작업을 직접 실행하고 처리해주는 역할
    - 우리가 특별한 함수를 사용해서 코드를 비동기적으로 동작하도록 설정한 게 아니라면, 기본적으로 JavaScript는 **동기**적으로 코드를 실행한다.
    - 우리가 작성한 프로그램의 실행 흐름을 읽을 때 위에서부터 아래로 실행된다고 생각하면 되기 때문에 **실행 흐름을 파악하기 쉽고 용이**하다.
    - 어떤 하나의 작업이 아주 오래 걸리는 작업이라면 쓰레드가 이 작업을 처리하기 전까지는 그 다음 작업을 진행할 수 없기 때문에 전체 프로그램의 성능이 악화되는 치명적인 문제 발생


    - Java나 C#에서는 이러한 문제를 해결하기 위해서 여러 개의 쓰레드를 동시에 사용하는 멀티 쓰레드라는 기법 활용
        - 멀티 쓰레드, 즉 여러 개의 쓰레드를 활용하면 오래 걸리는 작업이 중간에 포함되어 있다고 하더라도 해당 작업이 전체 프로그램의 성능을 악화시키는 데에는 큰 영향을 주지 않기 때문에 동기 방식의 단점을 어느 정도 보완할 수 있다.

    - But,  **JavaScript** 엔진에는 **쓰레드가 1개**밖에 없다!!! → 멀티 쓰레드 방식으로는 문제를 해결할 수 없다. ⇒ **비동기**라는 방식을 통해서 해결!

2. **비동기란 무엇일까?**
    - 동기적이지 않다는 뜻
    - 여러 개의 작업을 순서대로 처리하지 않음
    - 여러 개의 작업이 있을 때, 앞선 작업이 종료되지 않아도 기다릴 필요 없이 다른 작업을 동시에 진행시키는 게 가능하다.
    - 각각의 작업이 종료되었을 때 해당 작업의 결과값을 이용해서 또 다른 동작을 수행시켜줘야 한다면 각각의 작업에 콜백함수를 붙여서 처리해주는 것도 가능하다.


    - **setTimeout()** - 비동기적으로 작동하는 특수한 내장함수
        - 우리가 원하는 코드를 특정 시간이 지난 이후에 비동기적으로 실행시켜주는 기능을 가지고 있다.
        - 첫 번째 인수로 콜백함수를 전달하고 두 번째 인수로 숫자값을 전달해주면 두 번째로 전달한 숫자값에 해당하는 ms만큼 대기했다가 그 시간이 지나면 첫 번째 인수로 전달한 콜백함수를 실행시켜준다.
- **JavaScript는 싱글 쓰레드인데 어떻게 동시에 여러 개의 작업을 처리하는 것인가?**
    - 비동기 작업들은 JavaScript 엔진이 아닌 Web APIs에서 실행된다.
    - **Web APIs**: 웹 브라우저가 직접 관리하는 별도의 영역
    
    - JavaScript 엔진은 코드를 한 줄씩 실행하다가 비동기 함수를 만나게 되면 브라우저의 Web APIs에게 실행해달라고 부탁한다 → 타이머가 끝나면 실행할 콜백함수까지 같이 넘겨준다 → 그러고 나서 JavaScript 엔진은 타이머를 기다리지 않고 아래에 있는 작업을 즉시 실행한다 → Web APIs에 있는 타이머가 완료되면 전달 받았던 콜백함수를 다시 JavaScript 엔진에게 돌려준다 →  JavaScript 엔진은 그제서야 돌려받은 콜백함수를 실행시킴으로써 이러한 방식으로 비동기 처리가 이루어진다.



---
### **2.12) 비동기 작업 처리하기 1. 콜백함수**

- 비동기 작업을 하는 함수의 결과값을 함수 외부에서 이용하고 싶다면, 콜백함수를 사용해서 비동기 함수 안에서 콜백함수를 호출하도록 설정하면 된다.

    ```jsx
    function add(a, b, callback) {
        setTimeout(() => {
            const sum = a + b   // 3
            callback(sum)
        }, 3000);
    }

    add(1, 2, (value) => {      // 3초 후 인수로 전달한 콜백 함수 실행
        console.log(value)
    })
    ```

- Ex) 음식을 주문하는 상황
    
    ```jsx
    function orderFood(callback) {
        setTimeout(() => {
            const food = "떡볶이"
            callback(food)
        }, 3000);
    }
    
    function cooldownFood(food, callback) {
        setTimeout(() => {
            const cooldownedFood = `식은 ${food}`
            callback(cooldownedFood)
        }, 2000);
    }
    
    function freezeFood(food, callback) {
        setTimeout(() => {
            const freezedFood = `냉동된 ${food}`
            callback(freezedFood)
        }, 1500);
    }
    
    orderFood((food) => {
        console.log(food)   // 3초 뒤 출력
    
        cooldownFood(food, (cooldownedFood) => {
            console.log(cooldownedFood)   // 5초 뒤 출력
    
            freezeFood(cooldownedFood, (freezedFood) => {
                console.log(freezedFood)    // 6.5초 뒤 출력
            })
        })
    }) 
    ```
    
    - 기능이 늘어날수록 인덴트(들여쓰기)가 점점 깊어지는 형태 → 가독성이 점점 안 좋아진다. ⇒ 콜백 지옥 ⇒ 비동기 작업을 도와주는 객체인 **promise**를 이용



---
### **2.13) 비동기 작업 처리하기 2. Promise**

**Promise란?**

- 비동기 작업을 효율적으로 처리할 수 있도록 도와주는 JavaScript의 내장 객체
- setTimeout()과 같은 비동기 작업들을 감싸는(wrapping) 객체


- 감싸고 있는 비동기 작업을 실행시켜주거나 현재 상태를 관리하거나 또는 비동기 작업의 결과를 저장해주거나 심지어는 여러 개의 작업을 병렬로 동시에 실행시켜준다거나 다시 실행시켜주는 등 비동기 작업을 처리하는데 필요한 거의 모든 기능을 다 제공해주는 객체


- Promise는 진행 단계에 따라서 3가지의 형태로 나눠서 관리한다.
    - **대기(Pending)**: 아직 비동기 작업이 진행 중인 , 아직 작업이 완료되지 않은 상태
    - **성공(Fulfilled)**: 비동기 작업이 별다른 오류 없이 성공적으로 마무리된 상태
    - **실패(Rejected)**: 비동기 작업이 모종의 이유로 실패한 상태

    
    - 해결(resolve): 어떤 비동기 작업이 대기 상태였다가 성공 상태로 바뀌는 것
    - 거부(reject): 대기 상태였다가 실패 상태로 바뀌는 것
    - Ex) 유튜브
        - 유튜브 영상 로딩 → 대기 상태
        - 영상 로딩 완료 → 해결
        - 시청 가능한 자체 → 성공 상태
        - 영상 로딩 실패 → 거부
        - 시청 불가능한 상태 → 실패 상태
- Promise 객체는 생성자(new Promise()) 이용
    - 생성자의 인수로는 비동기 작업을 실제로 진행할 콜백함수를 넣어주면 된다.
    - 콜백함수 안에 비동기 작업을 진행할 코드를 작성하면 promise 객체가 생성됨과 동시에 자동으로 콜백함수를 호출해서 안에 있는 비동기 작업들을 실행 ⇒ 이 콜백함수를 실제로 비동기 작업을 실행하는 함수라는 뜻에서 executor라고 부른다
    
    ```jsx
    const promise = new Promise(() => {
        // 비동기 작업 실행하는 함수
        // executor
    
        setTimeout(() => {
            console.log("안녕")
        }, 2000);
    })
    
    console.log(promise)    // promise 객체 -> 대기 상태, 결과값 -> undefined
    ```
    
    - executor 함수에는 두 가지(resolve, reject)의 매개변수가 전달된다.
        - resolve라는 첫 번째 매개변수에는 promise(비동기) 작업을 성공 상태로 바꾸는 함수가 들어있고, reject라는 두 번째 매개변수에는 promise가 관리하는 비동기 작업을 실패 상태로 바꾸는 함수가 들어있다.
    - executor에서 실행하는 비동기 작업이 성공했다고 알리고 싶다면 resolve 함수를 호출하면 된다.
        - 결과값은 executor 함수 내부에서 resolve 함수를 호출하면서 인수로 전달해줘야 한다.
        - 아무것도 전달하지 않으면 undefined
        
        ```jsx
        const promise = new Promise((resolve, reject) => {
            // 비동기 작업 실행하는 함수
            // executor
        
            setTimeout(() => {
                console.log("안녕")
                resolve("안녕")
            }, 2000);
        })
        
        setTimeout(() => {
            console.log(promise)    // promise 객체 -> 성공 상태("fulfilled"), 결과값 -> "안녕"
        }, 3000)
        ```
        
    - reject 함수 → 오류 메세지 먼저 출력
        - executor 함수에서 reject를 호출하게 되면 promise의 비동기 작업이 실패하게 되는 것이다.
        - 인수로 promise의 결과값을 전달해줄 수 있다.
        
        ```jsx
        const promise = new Promise((resolve, reject) => {
        
            setTimeout(() => {
                console.log("안녕")
                reject("왜 실패했는지 이유...")
            }, 2000);
        })
        
        setTimeout(() => {
            console.log(promise)    // promise 객체 -> 실패 상태("rejected"), 결과값 -> "왜 실패했는지 이유..."
        }, 3000)
        ```
        
    - then 메서드
        - executor 함수에서 resolve를 호출하게 되면 그 후에 then 메서드에 전달한 콜백함수를 실행시켜준다. 동시에 resolve에 전달한 결과값을 매개변수로까지 제공해준다.
        - promise로 관리하는 비동기 작업의 결과값을 언제든지 자유롭게 불러서 이용 가능
        - reject가 호출되어서 실패한다면, then 메서드는 실행되지 않는다 → then 메서드는 promise의 비동기 작업이 성공했을 때만 호출되는 메서드이기 때문 ⇒ catch 메서드 사용
    - catch 메서드
        - 실패 버전의 then 메서드
        - 인수로 콜백함수를 전달 → promise가 실패했을 때 콜백함수를 실행시켜준다.
        - 매개변수로 결과값까지 제공해준다.
    
    ```jsx
    const promise = new Promise((resolve, reject) => {
        setTimeout(() => {
            const num = null
    
            if (typeof num === "number") {
                resolve(num + 10)
            } else {
                reject("num이 숫자가 아닙니다.")
            }
        }, 2000);
    })
    
    // then 메서드
    // -> 그 후에
    promise.then((value) => {
        console.log(value)
    })
    
    promise.catch((error) => {
        console.log(error)  // num이 숫자가 아닙니다.
    })
    
    // 위 코드와 동일하지만, 더 간단
    // promise chaining
    promise
        .then((value) => {
            console.log(value)
        })
        .catch((error) => {
            console.log(error)  // num이 숫자가 아닙니다.
        })
    ```
    
    - promise 객체를 이용할 때 then과 catch 메서드를 잘 활용하면 promise가 관리하는 비동기 작업이 성공하거나 실패했을 때 그 결과값을 이용할 수 있다.
    - then과 catch를 연달아서 사용 → promise chaining
    - promise 객체를 이용해도 비동기 작업의 결과를 또 다른 비동기 작업의 인수로 전달할 수 있다.
    
    ```jsx
    function add10(num) {
        const promise = new Promise((resolve, reject) => {
    
            setTimeout(() => {
        
                if (typeof num === "number") {
                    resolve(num + 10)
                } else {
                    reject("num이 숫자가 아닙니다.")
                }
            }, 2000);
        })
    
        return promise
    }
    
    add10(0)
      .then((result) => {
        console.log(result)     // 10
        return add10(result)
      })
      .then((result) => {
        console.log(result)     // 20
        return add10(undefined)
      })
      .then((result) => {
        console.log(result)     
      })
      .catch((error) => {
        console.log(error)      // num이 숫자가 아닙니다.
      })
    ```
    
    - API를 호출 or 다른 서버와의 통신 등 → promise 객체가 굉장히 활발하게 사용된다.



---
### **2.14) 비동기 작업 처리하기 3. Async&Await**

**Async란?**

- 함수 앞에 붙이는 키워드
- 어떤 함수를 비동기 함수로 만들어주는 키워드
- 함수가 promise를 반환하도록 변환해주는 키워드

```jsx
// async

// 서버로부터 유저의 데이터를 받아오는 함수
async function getData() {
    return {
        name: "이정환",
        id: "winterlood",
    }
}
// async -> 객체를 그대로 반환하는 함수가 아니라, 
// 이 객체를 결과값으로 갖는 새로운 promise를 반환하는 함수로 변환됨

console.log(getData())  
/* 
Promise {<fulfilled>: {…}}
[[Prototype]]
: 
Promise
[[PromiseState]]
: 
"fulfilled"
[[PromiseResult]]
: 
Object
*/
```

- 애초에 비동기 함수를 반환하도록 하는 함수였다면, async의 키워드가 별다른 일을 하지 않고 promise가 반환되도록 내버려둔다.

```jsx
// async
async function getData() {
    return new Promise((resolve, reject) => {
        setTimeout(() => {
            resolve({
                name: "이정환",
                id: "winterlood",
            })
        }, 1500);
    })
}

console.log(getData())  
```

- async는 promise를 반환하지 않는 함수에 붙여서 자동으로 해당 함수를 비동기로 작동하도록 변환하는 기능을 한다.
- await이랑 같이 사용했을 때 그 위력이 제대로 발휘가 된다.

**Await이란?**

- async 함수 내부에서만 사용이 가능한 키워드 → async가 붙지 않은 함수에서 사용하면 오류 발생
- 비동기 함수가 다 처리되기를 기다리는 역할 → 결과값 반환
- then 메서드를 사용하지 않아도 된다.

```jsx
// await

async function printData() {
    const data = await getData()
    console.log(data)
}

printData()     // {name: '이정환', id: 'winterlood'}
```

- **async와 await을 이용하면 비동기 작업을 마치 동기 작업을 처리하듯이 아주 간결한 코드로 실행할 수 있다.**